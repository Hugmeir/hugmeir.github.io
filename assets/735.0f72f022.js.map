{"version":3,"file":"assets/735.0f72f022.js","mappings":"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","sources":["webpack://@xivanalysis/client/./src/parser/core/modules/ActionTimeline/ActionTimeline.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/ActionTimeline/ActionTimeline.module.css?2f05","webpack://@xivanalysis/client/./src/parser/core/modules/Defensives.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/DoTs.ts","webpack://@xivanalysis/client/./src/parser/core/modules/Overheal.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/Statuses.ts"],"sourcesContent":["import {Trans} from '@lingui/react'\nimport {Action, ActionKey} from 'data/ACTIONS'\nimport {Analyser} from 'parser/core/Analyser'\nimport {dependency} from 'parser/core/Injectable'\nimport CastTime from 'parser/core/modules/CastTime'\nimport {ChargeHistoryEntry, CooldownEndReason, CooldownGroup, CooldownHistoryEntry, Cooldowns, SelectionSpecifier} from 'parser/core/modules/Cooldowns'\nimport {Data} from 'parser/core/modules/Data'\nimport {ActionItem, BaseItem, ContainerRow, SimpleItem, Timeline} from 'parser/core/modules/Timeline'\nimport React, {ReactNode} from 'react'\nimport {Icon} from 'semantic-ui-react'\nimport {ensureArray, isDefined} from 'utilities'\nimport styles from './ActionTimeline.module.css'\n\nconst ANIMATION_LOCK = 100\n\n// We're excluding the Action interface as it's unessecary for this config format, and complicates the discrimination later.\ntype RowSpecifierEntry = Exclude<SelectionSpecifier, Action>\n\n/**\n * One or more actions, action keys, or cooldown group IDs. The special-case\n * value \"GCD\" is available for selection of the GCD cooldown group.\n */\nexport type RowSpecifier = RowSpecifierEntry | RowSpecifierEntry[]\n\n/** Advanced configuration options for a row. */\nexport interface ActionRowConfig {\n\t/** Specifier(s) for items that should be displayed in this row. */\n\tcontent: RowSpecifier\n\t/** Label to display for the row. */\n\tlabel?: ReactNode\n\t/** Order of the row within the timeline. */\n\torder?: number\n\t/** For multi-action rows, should we resolve the name of the action late?\n\t*  This allows setting the name of the row to whatever actions was first used\n\t*  of the set of possibilities.\n\t* */\n\tlateResolveLabel?: boolean\n}\n\n/** Configuration for a single row. */\nexport type ActionRow = RowSpecifier | ActionRowConfig\n\n// Internal row config used within the module\ntype InternalRowConfig =\n\t& Omit<ActionRowConfig, 'content'>\n\t& {content: readonly SelectionSpecifier[]}\n\nenum ItemDepth {\n\tCHARGE_GAIN = 0,\n\tACTION = 1,\n}\n\nexport class ActionTimeline extends Analyser {\n\tstatic override handle = 'actionTimeline'\n\tstatic override debug = false\n\n\t/**\n\t * Configuration for the rows generated by this module. Any cooldown groups\n\t * not represented in this configuration will be added to automatically\n\t * generated rows in order of use.\n\t */\n\tstatic rows: ActionRow[] = [\n\t\t{content: 'GCD', order: -97},\n\t]\n\n\t@dependency private castTime!: CastTime\n\t@dependency private cooldowns!: Cooldowns\n\t@dependency private data!: Data\n\t@dependency private timeline!: Timeline\n\n\tprivate resolvedRows: InternalRowConfig[] = []\n\tprivate groupRows = new Map<CooldownGroup, ContainerRow>()\n\n\t/** Retrieve the timeline row representing the specified action. */\n\tgetRow(action: ActionKey | Action) {\n\t\treturn this.addRow({content: [action]})\n\t}\n\n\toverride initialise() {\n\t\t// Add rows for all the configured entries\n\t\tfor (const config of (this.constructor as typeof ActionTimeline).rows) {\n\t\t\tconst resolvedConfig = this.resolveConfig(config)\n\t\t\tthis.resolvedRows.push(resolvedConfig)\n\t\t\tthis.addRow(resolvedConfig)\n\t\t}\n\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\tprotected resolveRowLabel(config: InternalRowConfig) {\n\t\tfor (const maybeAction of config.content) {\n\t\t\tlet fullAction = undefined\n\t\t\tif (typeof maybeAction === 'object') {\n\t\t\t\tfullAction = maybeAction\n\t\t\t} else if (typeof maybeAction === 'number') {\n\t\t\t\tfullAction = this.data.getAction(maybeAction)\n\t\t\t} else if (typeof maybeAction === 'string') {\n\t\t\t\tfullAction = this.data.actions[maybeAction as ActionKey]\n\t\t\t}\n\t\t\tif (fullAction === undefined || fullAction === null) { continue }\n\n\t\t\tconst uses = this.cooldowns.cooldownHistory(fullAction.id) ?? []\n\t\t\tif (uses.length === 0) { continue }\n\n\t\t\treturn uses[0].action.name\n\t\t}\n\t}\n\tprivate onComplete() {\n\t\t// Track the groups with configured rows so backfill doesn't duplicate\n\t\tconst populatedGroups = new Set<number>()\n\n\t\t// Add rows for all the configured entries\n\t\tfor (const config of this.resolvedRows) {\n\t\t\tconst row = this.addRow(config)\n\t\t\tif (config.lateResolveLabel) {\n\t\t\t\t// Resolve the label for multi-action rows late, by finding which one\n\t\t\t\t// of the actions was first used\n\t\t\t\trow.label = this.resolveRowLabel(config) ?? row.label\n\t\t\t}\n\t\t\tthis.populateRow(row, config)\n\t\t\tconfig.content.forEach(specifier =>\n\t\t\t\tthis.cooldowns.groups(specifier).forEach(group => populatedGroups.add(group))\n\t\t\t)\n\t\t}\n\n\t\t// Figure out what groups have not been explicitly configured and build rows for them\n\t\tthis.cooldowns.allGroups()\n\t\t\t.filter(group => !populatedGroups.has(group))\n\t\t\t.forEach(group => {\n\t\t\t\tconst config = {content: [group]}\n\t\t\t\tconst row = this.addRow(config)\n\t\t\t\tthis.populateRow(row, config)\n\t\t\t})\n\t}\n\n\tprivate resolveConfig(config: ActionRow): InternalRowConfig {\n\t\t// Standardise the simple config into the main config shape\n\t\tlet finalConfig = config\n\t\tif (typeof finalConfig !== 'object' || Array.isArray(finalConfig)) {\n\t\t\tfinalConfig = {content: finalConfig}\n\t\t}\n\t\treturn {\n\t\t\t...finalConfig,\n\t\t\tcontent: ensureArray(finalConfig.content),\n\t\t}\n\t}\n\n\tprivate addRow(config: InternalRowConfig) {\n\t\t// If there's already a row for one of the specifiers, use it\n\t\tconst groups = config.content.flatMap(specifier => this.cooldowns.groups(specifier))\n\t\tconst existingRow = groups\n\t\t\t.map(group => this.groupRows.get(group))\n\t\t\t.find(isDefined)\n\t\tif (existingRow != null) {\n\t\t\treturn existingRow\n\t\t}\n\n\t\t// Using an IIFE because pattern matching isn't in the spec yet\n\t\tconst firstContent = config.content[0]\n\t\tconst label = (() => {\n\t\t\tif (config.label != null) { return config.label }\n\t\t\tif (firstContent === 'GCD')  { return <Trans id=\"core.action-timeline.label.gcd\">GCD</Trans> }\n\t\t\tif (typeof firstContent === 'string') { return this.data.actions[firstContent].name }\n\t\t\tif (typeof firstContent === 'number') { return this.cooldowns.cooldownHistory(firstContent)[0]?.action.name }\n\t\t\treturn firstContent.name\n\t\t})()\n\n\t\t// Build the row and save it to the groups for this config\n\t\t// TODO: collision handling?\n\t\tconst row = this.timeline.addRow(new ContainerRow({\n\t\t\tlabel,\n\t\t\torder: config.order,\n\t\t\tcollapse: true,\n\t\t}))\n\t\tgroups.forEach(group => this.groupRows.set(group, row))\n\n\t\treturn row\n\t}\n\n\tprivate populateRow(row: ContainerRow, {content}: InternalRowConfig) {\n\t\t// Add all the items\n\t\tthis.addCooldownItems(row, content.flatMap(specifier => this.cooldowns.cooldownHistory(specifier)))\n\t\tthis.addChargeItems(row, content.flatMap(specifier => this.cooldowns.chargeHistory(specifier)))\n\t}\n\n\tprivate addCooldownItems(row: ContainerRow, history: CooldownHistoryEntry[]) {\n\t\tfor (const entry of history) {\n\t\t\tconst duration = this.getCooldownDuration(entry)\n\n\t\t\t// TODO: with the adjusted cast time we might get some overlaps, should we try to avoid that?]\n\t\t\t// TODO: Add interrupt visuals. CD2 only records interrupts within the bounds of a cooldown, so we'll need to track it in some manner for long-cast actions.\n\t\t\tconst start = entry.start - this.parser.pull.timestamp\n\t\t\tconst end = start + duration\n\t\t\trow.addItem(new SimpleItem({\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tcontent: <div className={styles.cooldown}/>,\n\t\t\t}))\n\t\t}\n\t}\n\n\tprivate addChargeItems(row: ContainerRow, history: ChargeHistoryEntry[]) {\n\t\tfor (const entry of history) {\n\t\t\tconst item = entry.delta < 0\n\t\t\t\t? new ActionItem({\n\t\t\t\t\tdepth: ItemDepth.ACTION,\n\t\t\t\t\tstart: entry.timestamp - this.parser.pull.timestamp,\n\t\t\t\t\taction: entry.action,\n\t\t\t\t})\n\t\t\t\t: new ChargeGainItem({\n\t\t\t\t\tdepth: ItemDepth.CHARGE_GAIN,\n\t\t\t\t\tstart: entry.timestamp - this.parser.pull.timestamp,\n\t\t\t\t})\n\t\t\trow.addItem(item)\n\t\t}\n\t}\n\n\tprivate getCooldownDuration(entry: CooldownHistoryEntry) {\n\t\tlet duration = entry.end - entry.start\n\n\t\t// If the cooldown expired naturally, it _may_ have a cast time greater than its cooldown.\n\t\tif (entry.endReason === CooldownEndReason.EXPIRED) {\n\t\t\tconst castTime = this.castTime.forAction(entry.action.id, entry.start) ?? 0\n\n\t\t\t// We add the animation lock constant to the cast time to mimic the game's\n\t\t\t// behaviour - also sometimes known as \"caster tax\".\n\t\t\tduration = Math.max(duration, castTime + ANIMATION_LOCK)\n\t\t}\n\n\t\treturn duration\n\t}\n}\n\nclass ChargeGainItem extends BaseItem {\n\tContent = () => (\n\t\t<div className={styles.chargeGain}>\n\t\t\t<Icon name=\"angle double up\" className={styles.icon}/>\n\t\t</div>\n\t)\n}\n","// extracted by mini-css-extract-plugin\nexport default {\"backgroundColour\":\"rgba(213, 221, 246, .4)\",\"chargeColor\":\"color(rgba(213, 221, 246, .4) a(100%) l(-20%))\",\"cooldown\":\"ActionTimeline-module_cooldown__3u1x3\",\"chargeGain\":\"ActionTimeline-module_chargeGain__3-Of9\",\"icon\":\"ActionTimeline-module_icon__8OvsF\"};","import {t} from '@lingui/macro'\nimport {Plural, Trans} from '@lingui/react'\nimport {ActionLink} from 'components/ui/DbLink'\nimport {Action, ActionKey} from 'data/ACTIONS'\nimport {JOBS, RoleKey} from 'data/JOBS'\nimport {Analyser} from 'parser/core/Analyser'\nimport {dependency} from 'parser/core/Injectable'\nimport {CooldownDowntime} from 'parser/core/modules/CooldownDowntime'\nimport {Data} from 'parser/core/modules/Data'\nimport React, {Fragment, ReactNode} from 'react'\nimport {Accordion, Button, Icon, Message, Table} from 'semantic-ui-react'\nimport {CooldownEndReason, CooldownHistoryEntry, Cooldowns} from './Cooldowns'\nimport DISPLAY_ORDER from './DISPLAY_ORDER'\nimport {Timeline} from './Timeline'\n\nconst DEFENSIVE_ROLE_ACTIONS: Map<RoleKey, ActionKey[]> = new Map<RoleKey, ActionKey[]>([\n\t['TANK', ['RAMPART', 'REPRISAL']],\n\t['MELEE', ['FEINT', 'BLOODBATH', 'SECOND_WIND']],\n\t['PHYSICAL_RANGED', ['SECOND_WIND']],\n\t['MAGICAL_RANGED', ['ADDLE']],\n\t['HEALER', []],\n])\n\nexport class Defensives extends Analyser {\n\tstatic override handle = 'defensives'\n\tstatic override title = t('core.defensives.title')`Defensives`\n\tstatic override displayOrder = DISPLAY_ORDER.DEFENSIVES\n\n\t@dependency protected cooldowns!:Cooldowns\n\t@dependency protected cooldownDowntime!: CooldownDowntime\n\t@dependency protected data!: Data\n\t@dependency private timeline!: Timeline\n\n\t/**\n\t * Implementing modules should provide a list of job-specific defensive actions to track\n\t */\n\tprotected trackedDefensives: Action[] = []\n\t/**\n\t * Implementing modules may override the main header message text\n\t */\n\tprotected headerContent: ReactNode = <Trans id=\"core.defensives.header.content\">\n\t\tUsing your mitigation and healing cooldowns can help you survive mistakes, or relieve some stress on the healers and let them deal more damage.<br/>\n\t\tWhile you shouldn't use them at the expense of your rotation or buff alignment, you should try to find helpful times to use them.\n\t</Trans>\n\n\toverride initialise() {\n\t\tconst roleDefensives = DEFENSIVE_ROLE_ACTIONS.get(JOBS[this.parser.actor.job].role)?.map(key => this.data.actions[key]) ?? []\n\t\troleDefensives.forEach(roleAction => {\n\t\t\tif (!this.trackedDefensives.find(action => roleAction.id === action.id)) {\n\t\t\t\tthis.trackedDefensives.push(roleAction)\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate getUsageCount(defensive: Action): number {\n\t\treturn this.getUses(defensive).length\n\t}\n\n\tprivate getUses(defensive: Action): CooldownHistoryEntry[] {\n\t\treturn this.cooldowns.cooldownHistory(defensive).filter((entry) => entry.endReason !== CooldownEndReason.INTERRUPTED)\n\t}\n\n\tprivate getMaxUses(defensive: Action): number {\n\t\tconst totalAdditionalUses = this.getUses(defensive).reduce((acc, usage) => acc + this.getAdditionalUsageData(defensive, usage.start).chargesBeforeNextUse, this.getAdditionalUsageData(defensive).chargesBeforeNextUse)\n\t\treturn this.getUsageCount(defensive) + totalAdditionalUses\n\t}\n\n\toverride output() {\n\t\tif (this.trackedDefensives.length === 0) {\n\t\t\treturn\n\t\t}\n\n\t\treturn <Fragment>\n\t\t\t<Message icon>\n\t\t\t\t<Icon name=\"info\" />\n\t\t\t\t<Message.Content>\n\t\t\t\t\t{this.headerContent}\n\t\t\t\t\t<br/><br/>\n\t\t\t\t\t<Trans id=\"core.defensives.header.sub-content\">\n\t\t\t\t\t\tThe below tables will show you where you can gain additional uses of these cooldowns, without interfering with your existing ones.\n\t\t\t\t\t</Trans>\n\t\t\t\t</Message.Content>\n\t\t\t</Message>\n\t\t\t<Accordion\n\t\t\t\texclusive={false}\n\t\t\t\tstyled\n\t\t\t\tfluid\n\t\t\t\tpanels={\n\t\t\t\t\tthis.trackedDefensives.map((defensive, index) => {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tkey: defensive.id,\n\t\t\t\t\t\t\ttitle: {\n\t\t\t\t\t\t\t\tcontent: <><ActionLink key={index} {...defensive} /> - {this.getUsageCount(defensive)} / {this.getMaxUses(defensive)}</>,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\tcontent: <Table compact unstackable celled>\n\t\t\t\t\t\t\t\t\t<Table.Body>\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tthis.tryGetAdditionalUseRow(defensive)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tthis.getUses(defensive).map((entry) => {\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.getUsageRow(entry, defensive)\n\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t</Table.Body>\n\t\t\t\t\t\t\t\t</Table>,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t/>\n\t\t</Fragment>\n\t}\n\n\tprivate getUsageRow(entry: CooldownHistoryEntry, defensive: Action): ReactNode {\n\t\treturn <>\n\t\t\t<Table.Row key={entry.start}>\n\t\t\t\t<Table.Cell>\n\t\t\t\t\t<Trans id=\"core.defensives.table.usage-row.text\">Used at <Button\n\t\t\t\t\t\tcircular\n\t\t\t\t\t\tcompact\n\t\t\t\t\t\tsize=\"mini\"\n\t\t\t\t\t\ticon=\"time\"onClick={() => this.timeline.show(entry.start - this.parser.pull.timestamp, entry.end - this.parser.pull.timestamp)}>\n\t\t\t\t\t</Button> {this.parser.formatEpochTimestamp(entry.start)}\n\t\t\t\t\t</Trans>\n\t\t\t\t</Table.Cell>\n\t\t\t</Table.Row>\n\t\t\t{\n\t\t\t\tthis.tryGetAdditionalUseRow(defensive, entry.start)\n\t\t\t}\n\t\t</>\n\t}\n\n\tprivate getAdditionalUsageData(defensive: Action, timestamp: number = this.parser.pull.timestamp): {chargesBeforeNextUse: number, availableTimestamp: number, useByTimestamp: number} {\n\t\tlet availableTimestamp: number, currentCharges\n\n\t\tif (timestamp === this.parser.pull.timestamp) {\n\t\t\tavailableTimestamp = this.parser.pull.timestamp\n\t\t\tcurrentCharges = defensive.charges || 1\n\t\t} else {\n\t\t\tconst chargesAvailableEvent = this.cooldowns.chargeHistory(defensive).find(charges => charges.timestamp >= timestamp && charges.current > 0)\n\t\t\tavailableTimestamp = chargesAvailableEvent?.timestamp || (this.parser.pull.duration + this.parser.pull.timestamp)\n\t\t\tcurrentCharges = chargesAvailableEvent?.current || 0\n\t\t}\n\n\t\tconst cooldown = defensive.cooldown || this.parser.pull.duration\n\t\tconst nextEntry = this.getUses(defensive).find(historyEntry => historyEntry.start > timestamp)\n\t\tconst useByTimestamp = nextEntry != null ? (nextEntry.start - cooldown) : (this.parser.pull.timestamp + this.parser.pull.duration)\n\n\t\tif (useByTimestamp <= availableTimestamp) {\n\t\t\treturn {chargesBeforeNextUse: 0, availableTimestamp, useByTimestamp}\n\t\t}\n\n\t\treturn {chargesBeforeNextUse: currentCharges + Math.floor((useByTimestamp - availableTimestamp) / cooldown), availableTimestamp, useByTimestamp}\n\t}\n\n\tprivate tryGetAdditionalUseRow(defensive: Action, timestamp: number = this.parser.pull.timestamp): ReactNode {\n\t\tconst {chargesBeforeNextUse, availableTimestamp, useByTimestamp} = this.getAdditionalUsageData(defensive, timestamp)\n\n\t\tif (chargesBeforeNextUse === 0) {\n\t\t\treturn <></>\n\t\t}\n\n\t\treturn <Table.Row>\n\t\t\t<Table.Cell>\n\t\t\t\t<Trans id=\"core.defensives.table.extra-usage-row.text\"><Plural value={chargesBeforeNextUse} one=\"1 extra use\" other=\"# extra uses\"/> available between <Button\n\t\t\t\t\tcircular\n\t\t\t\t\tcompact\n\t\t\t\t\tsize=\"mini\"\n\t\t\t\t\ticon=\"time\"onClick={() => this.timeline.show(availableTimestamp - this.parser.pull.timestamp, useByTimestamp - this.parser.pull.timestamp)}>\n\t\t\t\t</Button> {this.parser.formatEpochTimestamp(availableTimestamp)} and {this.parser.formatEpochTimestamp(useByTimestamp)}\n\t\t\t\t</Trans>\n\t\t\t</Table.Cell>\n\t\t</Table.Row>\n\t}\n}\n","import {Status} from 'data/STATUSES'\nimport {Event, Events} from 'event'\nimport {Analyser} from 'parser/core/Analyser'\nimport {filter, oneOf} from 'parser/core/filter'\nimport {dependency} from 'parser/core/Injectable'\nimport {Actor, Actors} from 'parser/core/modules/Actors'\nimport {Data} from 'parser/core/modules/Data'\nimport {Invulnerability} from 'parser/core/modules/Invulnerability'\nimport {Statuses} from 'parser/core/modules/Statuses'\n\nconst MILLISECONDS_PER_MINUTE = 60000\n\ntype DotTracking = Map<Status['id'], Map<Actor['id'], DotTargetTracking>>\ninterface DotTargetTracking {\n\tlastApplied: number\n\ttotalClipping: number\n}\n\nexport abstract class DoTs extends Analyser {\n\tstatic override handle = 'dots'\n\n\t@dependency protected data!: Data\n\t@dependency private actors!: Actors\n\t@dependency private invulnerability!: Invulnerability\n\t@dependency private statuses!: Statuses\n\n\t/** Implementing modules MUST override this with a list of Status IDs. */\n\tprotected abstract trackedStatuses: number[] = []\n\n\tprivate statusApplications: DotTracking = new Map<number, Map<string, DotTargetTracking>>()\n\n\toverride initialise() {\n\t\tthis.addEventHook(\n\t\t\tfilter<Event>()\n\t\t\t\t.type('statusApply')\n\t\t\t\t.source(this.parser.actor.id)\n\t\t\t\t.status(oneOf(this.trackedStatuses)),\n\t\t\tthis.onApply,\n\t\t)\n\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\t/**\n\t * Implementing modules MUST override this to configure the checklist.\n\t * This should be handled on a job-by-job basis rather than generically, since the description\n\t * text isn't one-size-fits-all, and some jobs may have custom targets.\n\t */\n\tprotected abstract addChecklistRules(): void\n\n\t/**\n\t * Implementing modules MUST override this to configure suggestions.\n\t * This should be handled on a job-by-job basis rather than generically, since different jobs have\n\t * different thresholds for what constitutes bad clipping with varying explanations as to why.\n\t */\n\tprotected abstract addClippingSuggestions(): void\n\n\t/**\n\t * Implementing modules can optionally exclude applications of a status from clipping calculations.\n\t * (e.g. SMN rushing)\n\t */\n\tprotected excludeApplication() {\n\t\treturn false\n\t}\n\n\tprivate onApply(event: Events['statusApply']) {\n\t\tconst status = this.data.getStatus(event.status)\n\t\t// Cannot track for statuses that are not defined with a duration\n\t\tif (status?.duration == null) { return }\n\n\t\t// Get the tracking object for this status\n\t\tlet trackedStatus = this.statusApplications.get(status.id)\n\t\tif (trackedStatus == null) {\n\t\t\ttrackedStatus = new Map<string, DotTargetTracking>()\n\t\t\tthis.statusApplications.set(status.id, trackedStatus)\n\t\t}\n\n\t\t// Get the tracking object for this status on this target\n\t\tconst target = event.target\n\t\tlet trackedStatusOnTarget = trackedStatus.get(target)\n\t\tif (trackedStatusOnTarget == null) {\n\t\t\ttrackedStatusOnTarget = {lastApplied: 0, totalClipping: 0}\n\t\t\ttrackedStatus.set(target, trackedStatusOnTarget)\n\t\t}\n\n\t\t// If it's not been applied yet or should be excluded per job-specific logic (if any), set it and skip out\n\t\tif (trackedStatusOnTarget.lastApplied === 0 || this.excludeApplication()) {\n\t\t\ttrackedStatusOnTarget.lastApplied = event.timestamp\n\t\t\treturn\n\t\t}\n\n\t\t// Base clip calc\n\t\tconst clip = status.duration - (event.timestamp - trackedStatusOnTarget.lastApplied)\n\t\t// Cap clip at 0 - less than that is downtime, which is handled by the checklist requirement\n\t\ttrackedStatusOnTarget.totalClipping += Math.max(0, clip)\n\t\ttrackedStatusOnTarget.lastApplied = event.timestamp\n\t}\n\n\tprivate onComplete() {\n\t\tthis.addChecklistRules()\n\t\tthis.addClippingSuggestions()\n\t}\n\n\t// These two functions are helpers for submodules and should be used but not overridden\n\tprotected getUptimePercent(statusId: number) {\n\t\tconst status = this.data.getStatus(statusId)\n\t\tif (status == null) { return 0 }\n\n\t\tconst statusUptime = this.statuses.getUptime(status, this.actors.foes)\n\t\tconst fightDuration = this.parser.pull.duration - this.invulnerability.getDuration({types: ['invulnerable']})\n\t\treturn (statusUptime / fightDuration) * 100\n\t}\n\n\t// This normalises clipping as milliseconds clipped per minute,\n\t// since some level of clipping is expected and we need tiers that work for both long and short fights\n\tprotected getClippingAmount(statusId: number) {\n\t\tconst fightDuration = (this.parser.pull.duration - this.invulnerability.getDuration({types: ['invulnerable']}))\n\t\tif (fightDuration <= 0) { return 0 }\n\n\t\tconst statusApplications = this.statusApplications.get(statusId)\n\t\tif (statusApplications == null) { return 0 }\n\n\t\tconst totalClipping = Array.from(statusApplications.values()).reduce((clip, target) => clip + target.totalClipping, 0)\n\t\tconst clipMSPerMin = Math.round(totalClipping / (fightDuration / MILLISECONDS_PER_MINUTE))\n\t\treturn clipMSPerMin\n\t}\n}\n","import {Trans} from '@lingui/react'\nimport ACTIONS from 'data/ACTIONS'\nimport {Event, Events} from 'event'\nimport {Analyser, DisplayOrder} from 'parser/core/Analyser'\nimport {filter, oneOf} from 'parser/core/filter'\nimport {dependency} from 'parser/core/Injectable'\nimport Checklist, {Requirement, TARGET, TieredRule} from 'parser/core/modules/Checklist'\nimport {Data} from 'parser/core/modules/Data'\nimport {DataSet, PieChartStatistic, Statistics} from 'parser/core/modules/Statistics'\nimport Suggestions, {SEVERITY, TieredSuggestion} from 'parser/core/modules/Suggestions'\nimport React from 'react'\n\ninterface SeverityTiers {\n\t[key: number]: number\n}\n\ninterface TrackedOverhealOpts {\n\tbucketId?: number\n\tname: JSX.Element | string,\n\tcolor?: string\n\ttrackedHealIds?: number[],\n\tignore?: boolean\n\tdebugName?: string\n}\n\nconst REGENERATION_ID: number = 1302\n\nconst SUGGESTION_SEVERITY_TIERS: SeverityTiers = {\n\t0: SEVERITY.MINOR,\n\t35: SEVERITY.MEDIUM,\n\t50: SEVERITY.MAJOR,\n}\n\nconst CHECKLIST_SEVERITY_TIERS: SeverityTiers = {\n\t// eslint-disable-next-line @typescript-eslint/no-magic-numbers\n\t[100-35]: TARGET.SUCCESS,\n\t// eslint-disable-next-line @typescript-eslint/no-magic-numbers\n\t[100-50]: TARGET.WARN,\n}\n\nexport const SuggestedColors: string[] = [\n\t'#157f1f', // dark green\n\t'#12ba45', // light green\n\t'#00b5ad', // dark teal\n\t'#a0eade', // light teal\n\t'#b5cc18', // ~~snot green~~ why are you using this?\n]\n\nexport class TrackedOverheal {\n\tbucketId: number = -1\n\tignore: boolean\n\tname: JSX.Element | string\n\tcolor: string = '#fff'\n\tprotected trackedHealIds: number[]\n\theal: number = 0\n\toverheal: number = 0\n\tinternalDebugName: string | undefined\n\n\tconstructor(opts: TrackedOverhealOpts) {\n\t\tthis.name = opts.name\n\t\tthis.color = opts.color || this.color\n\t\tthis.trackedHealIds = opts.trackedHealIds || []\n\t\tthis.bucketId = opts.bucketId || -1\n\t\tthis.ignore = opts.ignore || false\n\t\tthis.internalDebugName = opts.debugName\n\t}\n\n\t/**\n\t * Get current overheal as a percentage\n\t */\n\tget percent(): number {\n\t\tif (this.heal > 0) { return 100 * (this.overheal / this.heal) }\n\t\treturn 0\n\t}\n\n\t/**\n\t * Get current overheal as an inverted percentage (for checklist)\n\t */\n\tget percentInverted(): number {\n\t\treturn 100 - this.percent\n\t}\n\n\t/**\n\t * Returns true if there's data to output\n\t */\n\tget hasData(): boolean {\n\t\tif (this.heal > 0 || this.overheal > 0) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\t/**\n\t * Gets a printable name for the category\n\t */\n\tget debugName(): string {\n\t\tif (this.internalDebugName != null) {\n\t\t\treturn this.internalDebugName\n\t\t}\n\n\t\tif (typeof this.name === 'string') {\n\t\t\treturn this.name\n\t\t}\n\n\t\t// Trans tags\n\t\tif (this.name.props.defaults != null) {\n\t\t\treturn this.name.props.defaults\n\t\t}\n\n\t\treturn 'Unknown'\n\t}\n\n\t/**\n\t * Returns true if the action id is tracked\n\t * @param guid\n\t */\n\tidIsTracked(guid: number): boolean {\n\t\tif (this.trackedHealIds.includes(guid)) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\t/**\n\t * Pushes a heal event in for tracking\n\t * @param event - The heal event to track\n\t */\n\tpushHeal(event: Events['heal']) {\n\t\tthis.heal += event.targets.reduce((total, target) => total + target.amount, 0)\n\t\tthis.overheal += event.targets.reduce((total, target) => total + target.overheal, 0)\n\t}\n}\n\nexport class Overheal extends Analyser {\n\tstatic override handle: string = 'overheal'\n\tstatic override debug = false\n\n\t@dependency private checklist!: Checklist\n\t@dependency protected data!: Data\n\t@dependency private suggestions!: Suggestions\n\t@dependency private statistics!: Statistics\n\n\t// Overall tracking options\n\n\t/**\n\t * Implementing modules MAY override this to provide a more relevant name for the overhealing requirement\n\t */\n\tprotected overhealName: JSX.Element = <Trans id=\"core.overheal.direct.name\">Direct</Trans>\n\t/**\n\t * Implementing moduels MAY override this to change the color for direct overheals in the pie chart\n\t */\n\tprotected overhealColor: string = SuggestedColors[0]\n\t/**\n\t * Implementing modules MAY override this to provide a list of heal 'categories' to track\n\t */\n\tprotected trackedHealCategories: TrackedOverhealOpts[] = []\n\n\t// Display options\n\n\t/**\n\t * Implementing modules MAY change this to true in order to spit out a spiffy pie chart\n\t * breakdown of all their categories they're tracking\n\t */\n\tprotected displayPieChart: boolean = false\n\n\t/**\n\t * Implementing modules MAY wish set this to true in order to provide a suggestion\n\t */\n\tprotected displaySuggestion: boolean = false\n\t/**\n\t * Implementing modules MAY change this to set the suggestion icon\n\t */\n\tprotected suggestionIcon: string = ACTIONS.SCH_PHYSICK.icon\n\t/**\n\t * Implementing mdoules MAY change this to set the suggestion text\n\t */\n\tprotected suggestionContent: JSX.Element = <Trans id=\"core.overheal.suggestion.content\">Avoid healing your party for more than is needed. Cut back on unnecessary heals and coordinate with your co-healer to plan resources efficiently.</Trans>\n\t/**\n\t * Implementing modules MAY change this to define the severity tiers for the suggestion\n\t */\n\tprotected suggestionSeverity: SeverityTiers = SUGGESTION_SEVERITY_TIERS\n\n\t/**\n\t * Implementing modules MAY wish to set this to false in order to suppress adding this as a\n\t * checklist item\n\t */\n\tprotected displayChecklist: boolean = true\n\t/**\n\t * Allows for more flexibility in ordering of the checklist if necessary.\n\t */\n\tprotected displayOrder = DisplayOrder.DEFAULT\n\t/**\n\t * Implementing modules MAY wish to override this to set custom severity tiers.\n\t * Do remember that the numbers for checklist are inverted for overheal (e.g., warning at\n\t * 35% overheal means you need to set your threshold at 65)\n\t */\n\tprotected checklistSeverity: SeverityTiers = CHECKLIST_SEVERITY_TIERS\n\t/**\n\t * Implementing modules MAY wish to override this to change the name for the checklist title\n\t */\n\tprotected checklistRuleName: JSX.Element = <Trans id=\"core.overheal.rule.name\">Avoid Overheal</Trans>\n\t/**\n\t * Implementing modules MAY wish to change this in order to reflect the overall healing requiement name\n\t */\n\tprotected checklistRequirementName: JSX.Element = <Trans id=\"core.overheal.requirement.all\">Overall (all sources)</Trans>\n\t/**\n\t * Implementing modules MAY change this to true in order to generate multiple requirements for each\n\t * category of tracked heals; leaving it at false will only generate a single requirement against\n\t * the total overheal percent\n\t */\n\tprotected checklistRuleBreakout: boolean = false\n\n\t// direct healing\n\tprotected direct!: TrackedOverheal\n\t// Everything else\n\tprotected trackedOverheals: TrackedOverheal[] = []\n\n\t/**\n\t * Implementing modules MAY override this to provide the 'why' for suggestion content\n\t * @param overhealPercent\n\t */\n\tprotected suggestionWhy(overhealPercent: number): JSX.Element {\n\t\treturn <Trans id=\"core.overheal.suggestion.why\">You had an overheal of { overhealPercent.toFixed(2) }%</Trans>\n\t}\n\n\toverride initialise() {\n\t\tthis.direct = new TrackedOverheal({\n\t\t\tname: this.overhealName,\n\t\t\tcolor: this.overhealColor,\n\t\t})\n\t\tfor (const healCategoryOpts of this.trackedHealCategories) {\n\t\t\tthis.trackedOverheals.push(new TrackedOverheal(healCategoryOpts))\n\t\t}\n\n\t\tthis.addEventHook(filter<Event>().type('heal').source(this.parser.actor.id), this.onHeal)\n\n\t\tconst actorPets = this.parser.pull.actors\n\t\t\t.filter(actor => actor.owner != null && actor.owner.id === this.parser.actor.id)\n\t\t\t.map(pet => pet.id)\n\t\tthis.addEventHook(filter<Event>().type('heal').source(oneOf(actorPets)), this.onPetHeal)\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\t/**\n\t * This method MAY be overridden to return true or false, indicating if a heal\n\t * should be counted. If true is returned, the heal is counted towards overheal;\n\t * false ignores the heal entirely.\n\t * @param event\n\t */\n\tprotected considerHeal(_event: Events['heal'], _pet: boolean = false): boolean {\n\t\treturn true\n\t}\n\n\t/**\n\t * This method MAY be overridden to provide an alternative checklist description\n\t * @param overheals - an array of all the categories of overheals you're tracking, starting with direct\n\t */\n\tprotected checklistDescription(_overheals: TrackedOverheal[]): JSX.Element {\n\t\treturn <Trans id=\"core.overheal.rule.description\">Avoid healing your party for more than is needed. Cut back on unnecessary heals and coordinate with your co-healer to plan resources efficiently.</Trans>\n\t}\n\n\t/**\n\t * This method MAY be overriden to force a heal into a specific bucket for whatever reason\n\t * @param _event - the healing event to consider\n\t * @param _petHeal - whether the heal comes from a pet or not; defaults to false\n\t * @returns a number for the bucket to for a heal into. Return -1 to bucket the heal normally\n\t */\n\tprotected overrideHealBucket(_event: Events['heal'], _petHeal: boolean = false): number {\n\t\treturn -1\n\t}\n\n\tprivate isRegeneration(event: Events['heal']): boolean {\n\t\treturn event.cause.type === 'action' && event.cause.action === REGENERATION_ID\n\t}\n\n\tprivate onHeal(event: Events['heal'], petHeal: boolean = false) {\n\t\tif (this.isRegeneration(event) || ! this.considerHeal(event, petHeal)) { return }\n\n\t\tconst guid = event.cause.type === 'action' ? event.cause.action : event.cause.status\n\t\tconst name = event.cause.type === 'action' ? this.data.getAction(guid)?.name : this.data.getStatus(guid)?.name\n\n\t\tconst bucketId = this.overrideHealBucket(event, petHeal)\n\t\tif (bucketId >= 0) {\n\t\t\tfor (const trackedHeal of this.trackedOverheals) {\n\t\t\t\tif (trackedHeal.bucketId === bucketId) {\n\t\t\t\t\tthis.debug(`Heal ${name} (${guid}) at ${event.timestamp} MANUALLY shoved into bucket ${trackedHeal.debugName}`)\n\t\t\t\t\ttrackedHeal.pushHeal(event)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn // return here because you might want to set multiple things with an id to match into multiple categories based on some criteria\n\t\t}\n\t\tfor (const trackedHeal of this.trackedOverheals) {\n\t\t\tif (trackedHeal.idIsTracked(guid)) {\n\t\t\t\tthis.debug(`Heal from ${name} (${guid}) at ${event.timestamp} matched into category ${trackedHeal.debugName}`)\n\t\t\t\ttrackedHeal.pushHeal(event)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tthis.debug(`Heal from ${name} (${guid}) at ${event.timestamp} matched into direct healing`)\n\t\tthis.direct.pushHeal(event)\n\t}\n\n\tprivate onPetHeal(event: Events['heal']) {\n\t\tthis.onHeal(event, true)\n\t}\n\n\tprivate percentageOf(category: number, total: number): number {\n\t\treturn (100 * category) / total\n\t}\n\n\tprivate onComplete() {\n\t\tlet healtotal = this.direct.heal\n\t\tlet overhealtotal = this.direct.overheal\n\n\t\tthis.trackedOverheals.forEach(x => {\n\t\t\tif (!x.ignore && x.hasData) {\n\t\t\t\thealtotal += x.heal\n\t\t\t\toverhealtotal += x.overheal\n\t\t\t}\n\t\t})\n\t\tconst overallOverhealPercent: number = 100 * overhealtotal / healtotal\n\n\t\tif (this.displayPieChart) {\n\t\t\tconst directPercentage = this.percentageOf(this.direct.overheal, overhealtotal)\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-magic-numbers\n\t\t\tconst data: DataSet<React.ReactNode, 3> = [{\n\t\t\t\tvalue: directPercentage,\n\t\t\t\tcolor: this.direct.color,\n\t\t\t\tcolumns: [\n\t\t\t\t\tthis.direct.name,\n\t\t\t\t\tthis.percentageOf(this.direct.overheal, overhealtotal).toFixed(2) + '%',\n\t\t\t\t\tthis.direct.percent.toFixed(2) + '%',\n\t\t\t\t],\n\t\t\t}]\n\n\t\t\tfor (const trackedHeal of this.trackedOverheals) {\n\t\t\t\tif (!trackedHeal.ignore && trackedHeal.hasData) {\n\t\t\t\t\tconst percentage = this.percentageOf(trackedHeal.overheal, overhealtotal)\n\t\t\t\t\tdata.push({\n\t\t\t\t\t\tvalue: percentage,\n\t\t\t\t\t\tcolor: trackedHeal.color,\n\t\t\t\t\t\tcolumns: [\n\t\t\t\t\t\t\ttrackedHeal.name,\n\t\t\t\t\t\t\tpercentage.toFixed(2) + '%',\n\t\t\t\t\t\t\ttrackedHeal.percent.toFixed(2) + '%',\n\t\t\t\t\t\t],\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.statistics.add(new PieChartStatistic({\n\t\t\t\theadings: [\n\t\t\t\t\t'Type of heal',\n\t\t\t\t\t'% of total overheal',\n\t\t\t\t\t'Overheal % per type',\n\t\t\t\t],\n\t\t\t\tdata: data,\n\t\t\t\twidth: 3, // chart's wide, yo\n\t\t\t}))\n\t\t}\n\n\t\tif (this.displayChecklist) {\n\t\t\tconst requirements: InvertedRequirement[] = []\n\t\t\tif (this.checklistRuleBreakout) {\n\t\t\t\trequirements.push(new InvertedRequirement({\n\t\t\t\t\tname: this.overhealName,\n\t\t\t\t\tpercent:  this.direct.percentInverted,\n\t\t\t\t\tweight: 0,\n\t\t\t\t}))\n\n\t\t\t\tfor (const trackedHeal of this.trackedOverheals) {\n\t\t\t\t\tif (trackedHeal.ignore) { continue }\n\n\t\t\t\t\trequirements.push(new InvertedRequirement({\n\t\t\t\t\t\tname: trackedHeal.name,\n\t\t\t\t\t\tpercent: trackedHeal.percentInverted,\n\t\t\t\t\t\tweight: 0,\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t\trequirements.push(new InvertedRequirement({\n\t\t\t\tname: this.checklistRequirementName,\n\t\t\t\tpercent: 100 - overallOverhealPercent,\n\t\t\t}))\n\n\t\t\tthis.checklist.add(new TieredRule({\n\t\t\t\tname: this.checklistRuleName,\n\t\t\t\tdescription: this.checklistDescription([this.direct, ...this.trackedOverheals]),\n\t\t\t\ttiers: this.checklistSeverity,\n\t\t\t\trequirements,\n\t\t\t\tdisplayOrder: this.displayOrder,\n\t\t\t}))\n\t\t}\n\n\t\tif (this.displaySuggestion) {\n\t\t\tthis.suggestions.add(new TieredSuggestion({\n\t\t\t\ticon: this.suggestionIcon,\n\t\t\t\ttiers: this.suggestionSeverity,\n\t\t\t\tvalue: overallOverhealPercent,\n\t\t\t\tcontent: this.suggestionContent,\n\t\t\t\twhy: this.suggestionWhy(overallOverhealPercent),\n\t\t\t}))\n\t\t}\n\t}\n}\n\n// From the original comments:\n// yeh, I'm not doing this in core, but I really want to show overheal as overheal, since that's what the community understands\n// So, in keeping with that spirit, I'm not going to export this at all.\nclass InvertedRequirement extends Requirement {\n\tget percentInverted() {\n\t\treturn 100 - this.percent\n\t}\n\n\toverride get content() {\n\t\tif (this._percent !== null || this.value === null) { return `${this.percentInverted.toFixed(2)}%` }\n\t\treturn `${this.value.toFixed(0)}/${this.target.toFixed(0)}` // avoid weird floating point shit\n\t}\n}\n","import {Status, StatusKey} from 'data/STATUSES'\nimport {Events} from 'event'\nimport {ensureArray} from 'utilities'\nimport {Analyser} from '../Analyser'\nimport {dependency} from '../Injectable'\nimport {Actor, StatusEvent} from './Actors'\nimport {Data} from './Data'\nimport {Invulnerability} from './Invulnerability'\n\ninterface Edge {\n\tside: 'apply' | 'remove'\n\ttimestamp: number\n}\n\nexport class Statuses extends Analyser {\n\tstatic override handle = 'statuses'\n\tstatic override debug = false\n\n\t@dependency private readonly data!: Data\n\t@dependency private readonly invulnerability!: Invulnerability\n\n\t/**\n\t * Calculate the total uptime of the specified status across allspecified actors.\n\t * @param statusSpecifier Status to calculate uptime of.\n\t * @param targetSpecifier Target(s) that should be checked for the status.\n\t * @param source Source of statuses to filter by. Defaults to the parsed actor.\n\t */\n\tgetUptime(\n\t\tstatusSpecifier: StatusKey | Status,\n\t\ttargetSpecifier: Actor | Actor[],\n\t\tsource = this.parser.actor\n\t) {\n\t\t// Resolve arguments.\n\t\tconst status = typeof statusSpecifier === 'string'\n\t\t\t? this.data.statuses[statusSpecifier]\n\t\t\t: statusSpecifier\n\n\t\tconst targets = ensureArray(targetSpecifier)\n\n\t\t// Collect all the status history for the specified status/target/source combo.\n\t\tconst edges = targets.flatMap(target => this.edgesForActor(\n\t\t\ttarget,\n\t\t\ttarget.statusHistory.get(status.id)?.get(source.id) ?? []\n\t\t))\n\n\t\t// Edges are mapped from multiple potential targets; interlace by sorting by timestamp.\n\t\tedges.sort((a, b) => a.timestamp - b.timestamp)\n\n\t\t// Sum time when any of the specified targets had the status.\n\t\tconst meta = {uptime: 0, depth: 0, application: 0}\n\t\tfor (const edge of edges) {\n\t\t\tif (edge.side === 'apply') {\n\t\t\t\tif (meta.depth === 0) {\n\t\t\t\t\tmeta.application = edge.timestamp\n\t\t\t\t}\n\t\t\t\tmeta.depth ++\n\n\t\t\t} else {\n\t\t\t\tmeta.depth --\n\t\t\t\tif (meta.depth === 0) {\n\t\t\t\t\tmeta.uptime += edge.timestamp - meta.application\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.debug(`Status ${status.name} ${edge.side} at ${this.ft(edge.timestamp)}, depth=${meta.depth}`)\n\t\t}\n\n\t\treturn meta.uptime\n\t}\n\n\tprivate edgesForActor(target: Actor, events: StatusEvent[]) {\n\t\t// We can safely assume status events from an actor will alternate between apply and remove.\n\t\tconst edges: Edge[] = []\n\t\tlet apply: Events['statusApply'] | undefined\n\t\tlet refresh: Events['statusApply'] | undefined\n\n\t\tfor (const event of events) {\n\t\t\t// Track the initial application and refreshes.\n\t\t\tif (event.type === 'statusApply') {\n\t\t\t\tapply ??= event\n\t\t\t\trefresh = event\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (apply == null) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Window has been closed, merge any edges in.\n\t\t\tedges.push(...this.splitRangeForInvulns(\n\t\t\t\ttarget,\n\t\t\t\tapply.timestamp,\n\t\t\t\tevent.timestamp\n\t\t\t))\n\t\t\tapply = undefined\n\t\t}\n\n\t\t// If we've got a dangling apply, build edges for it.\n\t\tif (apply != null) {\n\t\t\t// Try to find a reasonable remove time for the status, if it has a duration.  Cap to the end of the fight.\n\t\t\tconst statusDuration = this.data.getStatus(apply.status)?.duration\n\t\t\tconst remove = statusDuration == null\n\t\t\t\t? this.parser.currentEpochTimestamp\n\t\t\t\t: Math.min((refresh ?? apply).timestamp + statusDuration, this.parser.currentEpochTimestamp)\n\n\t\t\tedges.push(...this.splitRangeForInvulns(\n\t\t\t\ttarget,\n\t\t\t\tapply.timestamp,\n\t\t\t\tremove,\n\t\t\t))\n\t\t}\n\n\t\treturn edges\n\t}\n\n\tprivate splitRangeForInvulns(target: Actor, apply: number, remove: number): Edge[] {\n\t\tlet range = {apply, remove}\n\t\tconst finalRanges = [range]\n\n\t\t// Get the invuln windows that occured during this range\n\t\tconst invulns = this.invulnerability.getWindows({\n\t\t\tstart: apply,\n\t\t\tend: remove,\n\t\t\tactorFilter: actor => actor.kind === target.kind,\n\t\t\ttypes: ['invulnerable'],\n\t\t})\n\n\t\tfor (const invuln of invulns) {\n\t\t\t// Invuln clipped start of range.\n\t\t\tif (invuln.start < range.apply && invuln.end >= range.apply) {\n\t\t\t\tthis.debug(`Start clip, [${this.ft(range.apply)},${this.ft(range.remove)}] -> [${this.ft(invuln.end)},${this.ft(range.remove)}]`)\n\n\t\t\t\trange.apply = invuln.end\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Invuln clipped end of range.\n\t\t\tif (invuln.start <= range.remove && invuln.end > range.remove) {\n\t\t\t\tthis.debug(`End clip, [${this.ft(range.apply)},${this.ft(range.remove)}] -> [${this.ft(range.apply)},${this.ft(invuln.start)}]`)\n\n\t\t\t\trange.remove = invuln.start\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Everything else should be a range split, sanity check.\n\t\t\tif (invuln.start < range.apply || invuln.end > range.remove) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tthis.debug(`Split [${this.ft(range.apply)},${this.ft(range.remove)}] -> [${this.ft(range.apply)},${this.ft(invuln.start)}], [${this.ft(invuln.end)},${this.ft(range.remove)}]`)\n\n\t\t\t// Split the range into two around the invuln.\n\t\t\tconst previousRange = range\n\t\t\trange = {...range}\n\t\t\tfinalRanges.push(range)\n\n\t\t\tpreviousRange.remove = invuln.start\n\t\t\trange.apply = invuln.end\n\t\t}\n\n\t\t// Map the ranges into edges.\n\t\treturn finalRanges.flatMap(range => [\n\t\t\t{side: 'apply', timestamp: range.apply},\n\t\t\t{side: 'remove', timestamp: range.remove},\n\t\t] as const)\n\t}\n\n\t// Small utility for formatting timestamps, as we do it a _lot_ in debug messages\n\tprivate ft = (timestamp: number) => this.parser.formatEpochTimestamp(timestamp, 1)\n}\n"],"names":["ItemDepth","ActionTimeline","CastTime","Cooldowns","Data","Timeline","resolvedRows","groupRows","action","this","addRow","content","constructor","rows","config","resolvedConfig","resolveConfig","push","addEventHook","onComplete","maybeAction","fullAction","undefined","data","getAction","actions","uses","cooldowns","cooldownHistory","id","length","name","populatedGroups","row","lateResolveLabel","label","resolveRowLabel","populateRow","forEach","specifier","groups","group","add","allGroups","has","finalConfig","Array","isArray","ensureArray","existingRow","get","isDefined","firstContent","Trans","timeline","ContainerRow","order","collapse","set","addCooldownItems","addChargeItems","chargeHistory","history","entry","duration","getCooldownDuration","start","parser","pull","timestamp","end","addItem","SimpleItem","className","item","delta","ActionItem","depth","ACTION","ChargeGainItem","CHARGE_GAIN","endReason","CooldownEndReason","castTime","forAction","Math","max","Analyser","handle","debug","dependency","Content","styles","Icon","BaseItem","DEFENSIVE_ROLE_ACTIONS","Defensives","CooldownDowntime","trackedDefensives","headerContent","JOBS","actor","job","role","key","roleAction","defensive","getUses","totalAdditionalUses","acc","usage","getAdditionalUsageData","chargesBeforeNextUse","getUsageCount","Fragment","icon","exclusive","styled","fluid","panels","index","title","getMaxUses","compact","unstackable","celled","tryGetAdditionalUseRow","getUsageRow","formatEpochTimestamp","circular","size","onClick","show","availableTimestamp","currentCharges","charges","chargesAvailableEvent","current","cooldown","nextEntry","historyEntry","useByTimestamp","floor","displayOrder","DISPLAY_ORDER","cooldownDowntime","DoTs","Actors","Invulnerability","Statuses","trackedStatuses","statusApplications","filter","type","source","status","oneOf","onApply","event","getStatus","trackedStatus","target","trackedStatusOnTarget","lastApplied","totalClipping","excludeApplication","clip","addChecklistRules","addClippingSuggestions","statusId","statuses","getUptime","actors","foes","invulnerability","getDuration","types","fightDuration","round","SUGGESTION_SEVERITY_TIERS","SEVERITY","CHECKLIST_SEVERITY_TIERS","TARGET","SuggestedColors","TrackedOverheal","opts","bucketId","ignore","color","trackedHealIds","heal","overheal","internalDebugName","debugName","percent","props","defaults","guid","targets","total","amount","Overheal","Checklist","Suggestions","Statistics","overhealName","overhealColor","trackedHealCategories","displayPieChart","displaySuggestion","suggestionIcon","ACTIONS","suggestionContent","suggestionSeverity","displayChecklist","DisplayOrder","checklistSeverity","checklistRuleName","checklistRequirementName","checklistRuleBreakout","direct","trackedOverheals","overhealPercent","toFixed","healCategoryOpts","onHeal","actorPets","owner","pet","onPetHeal","_event","_overheals","cause","petHeal","isRegeneration","considerHeal","overrideHealBucket","trackedHeal","pushHeal","idIsTracked","category","healtotal","overhealtotal","x","hasData","overallOverhealPercent","value","percentageOf","columns","percentage","statistics","PieChartStatistic","headings","width","requirements","InvertedRequirement","percentInverted","weight","checklist","TieredRule","description","checklistDescription","tiers","suggestions","TieredSuggestion","why","suggestionWhy","_percent","Requirement","ft","statusSpecifier","targetSpecifier","edges","edgesForActor","statusHistory","a","b","meta","uptime","application","edge","side","events","apply","refresh","splitRangeForInvulns","statusDuration","remove","currentEpochTimestamp","min","range","finalRanges","invulns","getWindows","actorFilter","kind","invuln","previousRange"],"sourceRoot":""}