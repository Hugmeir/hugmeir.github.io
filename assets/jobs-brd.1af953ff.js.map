{"version":3,"file":"assets/jobs-brd.1af953ff.js","mappings":"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","sources":["webpack://@xivanalysis/client/./src/parser/core/modules/ActionTimeline/ActionTimeline.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/ActionTimeline/ActionTimeline.module.css?2f05","webpack://@xivanalysis/client/./src/parser/core/modules/AlwaysBeCasting.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/DoTs.ts","webpack://@xivanalysis/client/./src/parser/core/modules/GlobalCooldown.tsx","webpack://@xivanalysis/client/./src/parser/core/modules/Statuses.ts","webpack://@xivanalysis/client/./src/parser/jobs/brd/modules/ActionTimeline.tsx","webpack://@xivanalysis/client/./src/parser/jobs/brd/modules/AlwaysBeCasting.ts","webpack://@xivanalysis/client/./src/parser/jobs/brd/modules/DoTs.tsx","webpack://@xivanalysis/client/./src/parser/jobs/brd/modules/DriftingEa.tsx","webpack://@xivanalysis/client/./src/parser/jobs/brd/modules/Mitigation.tsx","webpack://@xivanalysis/client/./src/parser/jobs/brd/modules/MultiHitSkills.ts","webpack://@xivanalysis/client/./src/parser/jobs/brd/modules/DISPLAY_ORDER.ts","webpack://@xivanalysis/client/./src/parser/jobs/brd/modules/OGCDDowntime.ts","webpack://@xivanalysis/client/./src/parser/jobs/brd/modules/RagingStrikes.tsx","webpack://@xivanalysis/client/./src/parser/jobs/brd/modules/RefulgentProcs.tsx","webpack://@xivanalysis/client/./src/parser/jobs/brd/modules/index.ts"],"sourcesContent":["import {Trans} from '@lingui/react'\nimport {Action, ActionKey} from 'data/ACTIONS'\nimport {Analyser} from 'parser/core/Analyser'\nimport {dependency} from 'parser/core/Injectable'\nimport CastTime from 'parser/core/modules/CastTime'\nimport {ChargeHistoryEntry, CooldownEndReason, CooldownGroup, CooldownHistoryEntry, Cooldowns, SelectionSpecifier} from 'parser/core/modules/Cooldowns'\nimport {Data} from 'parser/core/modules/Data'\nimport {ActionItem, BaseItem, ContainerRow, SimpleItem, Timeline} from 'parser/core/modules/Timeline'\nimport React, {ReactNode} from 'react'\nimport {Icon} from 'semantic-ui-react'\nimport {ensureArray, isDefined} from 'utilities'\nimport styles from './ActionTimeline.module.css'\n\nconst ANIMATION_LOCK = 100\n\n// We're excluding the Action interface as it's unessecary for this config format, and complicates the discrimination later.\ntype RowSpecifierEntry = Exclude<SelectionSpecifier, Action>\n\n/**\n * One or more actions, action keys, or cooldown group IDs. The special-case\n * value \"GCD\" is available for selection of the GCD cooldown group.\n */\nexport type RowSpecifier = RowSpecifierEntry | RowSpecifierEntry[]\n\n/** Advanced configuration options for a row. */\nexport interface ActionRowConfig {\n\t/** Specifier(s) for items that should be displayed in this row. */\n\tcontent: RowSpecifier\n\t/** Label to display for the row. */\n\tlabel?: ReactNode\n\t/** Order of the row within the timeline. */\n\torder?: number\n\t/** For multi-action rows, should we resolve the name of the action late?\n\t*  This allows setting the name of the row to whatever actions was first used\n\t*  of the set of possibilities.\n\t* */\n\tlateResolveLabel?: boolean\n}\n\n/** Configuration for a single row. */\nexport type ActionRow = RowSpecifier | ActionRowConfig\n\n// Internal row config used within the module\ntype InternalRowConfig =\n\t& Omit<ActionRowConfig, 'content'>\n\t& {content: readonly SelectionSpecifier[]}\n\nenum ItemDepth {\n\tCHARGE_GAIN = 0,\n\tACTION = 1,\n}\n\nexport class ActionTimeline extends Analyser {\n\tstatic override handle = 'actionTimeline'\n\tstatic override debug = false\n\n\t/**\n\t * Configuration for the rows generated by this module. Any cooldown groups\n\t * not represented in this configuration will be added to automatically\n\t * generated rows in order of use.\n\t */\n\tstatic rows: ActionRow[] = [\n\t\t{content: 'GCD', order: -97},\n\t]\n\n\t@dependency private castTime!: CastTime\n\t@dependency private cooldowns!: Cooldowns\n\t@dependency private data!: Data\n\t@dependency private timeline!: Timeline\n\n\tprivate resolvedRows: InternalRowConfig[] = []\n\tprivate groupRows = new Map<CooldownGroup, ContainerRow>()\n\n\t/** Retrieve the timeline row representing the specified action. */\n\tgetRow(action: ActionKey | Action) {\n\t\treturn this.addRow({content: [action]})\n\t}\n\n\toverride initialise() {\n\t\t// Add rows for all the configured entries\n\t\tfor (const config of (this.constructor as typeof ActionTimeline).rows) {\n\t\t\tconst resolvedConfig = this.resolveConfig(config)\n\t\t\tthis.resolvedRows.push(resolvedConfig)\n\t\t\tthis.addRow(resolvedConfig)\n\t\t}\n\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\tprotected resolveRowLabel(config: InternalRowConfig) {\n\t\tfor (const maybeAction of config.content) {\n\t\t\tlet fullAction = undefined\n\t\t\tif (typeof maybeAction === 'object') {\n\t\t\t\tfullAction = maybeAction\n\t\t\t} else if (typeof maybeAction === 'number') {\n\t\t\t\tfullAction = this.data.getAction(maybeAction)\n\t\t\t} else if (typeof maybeAction === 'string') {\n\t\t\t\tfullAction = this.data.actions[maybeAction as ActionKey]\n\t\t\t}\n\t\t\tif (fullAction === undefined || fullAction === null) { continue }\n\n\t\t\tconst uses = this.cooldowns.cooldownHistory(fullAction.id) ?? []\n\t\t\tif (uses.length === 0) { continue }\n\n\t\t\treturn uses[0].action.name\n\t\t}\n\t}\n\tprivate onComplete() {\n\t\t// Track the groups with configured rows so backfill doesn't duplicate\n\t\tconst populatedGroups = new Set<number>()\n\n\t\t// Add rows for all the configured entries\n\t\tfor (const config of this.resolvedRows) {\n\t\t\tconst row = this.addRow(config)\n\t\t\tif (config.lateResolveLabel) {\n\t\t\t\t// Resolve the label for multi-action rows late, by finding which one\n\t\t\t\t// of the actions was first used\n\t\t\t\trow.label = this.resolveRowLabel(config) ?? row.label\n\t\t\t}\n\t\t\tthis.populateRow(row, config)\n\t\t\tconfig.content.forEach(specifier =>\n\t\t\t\tthis.cooldowns.groups(specifier).forEach(group => populatedGroups.add(group))\n\t\t\t)\n\t\t}\n\n\t\t// Figure out what groups have not been explicitly configured and build rows for them\n\t\tthis.cooldowns.allGroups()\n\t\t\t.filter(group => !populatedGroups.has(group))\n\t\t\t.forEach(group => {\n\t\t\t\tconst config = {content: [group]}\n\t\t\t\tconst row = this.addRow(config)\n\t\t\t\tthis.populateRow(row, config)\n\t\t\t})\n\t}\n\n\tprivate resolveConfig(config: ActionRow): InternalRowConfig {\n\t\t// Standardise the simple config into the main config shape\n\t\tlet finalConfig = config\n\t\tif (typeof finalConfig !== 'object' || Array.isArray(finalConfig)) {\n\t\t\tfinalConfig = {content: finalConfig}\n\t\t}\n\t\treturn {\n\t\t\t...finalConfig,\n\t\t\tcontent: ensureArray(finalConfig.content),\n\t\t}\n\t}\n\n\tprivate addRow(config: InternalRowConfig) {\n\t\t// If there's already a row for one of the specifiers, use it\n\t\tconst groups = config.content.flatMap(specifier => this.cooldowns.groups(specifier))\n\t\tconst existingRow = groups\n\t\t\t.map(group => this.groupRows.get(group))\n\t\t\t.find(isDefined)\n\t\tif (existingRow != null) {\n\t\t\treturn existingRow\n\t\t}\n\n\t\t// Using an IIFE because pattern matching isn't in the spec yet\n\t\tconst firstContent = config.content[0]\n\t\tconst label = (() => {\n\t\t\tif (config.label != null) { return config.label }\n\t\t\tif (firstContent === 'GCD')  { return <Trans id=\"core.action-timeline.label.gcd\">GCD</Trans> }\n\t\t\tif (typeof firstContent === 'string') { return this.data.actions[firstContent].name }\n\t\t\tif (typeof firstContent === 'number') { return this.cooldowns.cooldownHistory(firstContent)[0]?.action.name }\n\t\t\treturn firstContent.name\n\t\t})()\n\n\t\t// Build the row and save it to the groups for this config\n\t\t// TODO: collision handling?\n\t\tconst row = this.timeline.addRow(new ContainerRow({\n\t\t\tlabel,\n\t\t\torder: config.order,\n\t\t\tcollapse: true,\n\t\t}))\n\t\tgroups.forEach(group => this.groupRows.set(group, row))\n\n\t\treturn row\n\t}\n\n\tprivate populateRow(row: ContainerRow, {content}: InternalRowConfig) {\n\t\t// Add all the items\n\t\tthis.addCooldownItems(row, content.flatMap(specifier => this.cooldowns.cooldownHistory(specifier)))\n\t\tthis.addChargeItems(row, content.flatMap(specifier => this.cooldowns.chargeHistory(specifier)))\n\t}\n\n\tprivate addCooldownItems(row: ContainerRow, history: CooldownHistoryEntry[]) {\n\t\tfor (const entry of history) {\n\t\t\tconst duration = this.getCooldownDuration(entry)\n\n\t\t\t// TODO: with the adjusted cast time we might get some overlaps, should we try to avoid that?]\n\t\t\t// TODO: Add interrupt visuals. CD2 only records interrupts within the bounds of a cooldown, so we'll need to track it in some manner for long-cast actions.\n\t\t\tconst start = entry.start - this.parser.pull.timestamp\n\t\t\tconst end = start + duration\n\t\t\trow.addItem(new SimpleItem({\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tcontent: <div className={styles.cooldown}/>,\n\t\t\t}))\n\t\t}\n\t}\n\n\tprivate addChargeItems(row: ContainerRow, history: ChargeHistoryEntry[]) {\n\t\tfor (const entry of history) {\n\t\t\tconst item = entry.delta < 0\n\t\t\t\t? new ActionItem({\n\t\t\t\t\tdepth: ItemDepth.ACTION,\n\t\t\t\t\tstart: entry.timestamp - this.parser.pull.timestamp,\n\t\t\t\t\taction: entry.action,\n\t\t\t\t})\n\t\t\t\t: new ChargeGainItem({\n\t\t\t\t\tdepth: ItemDepth.CHARGE_GAIN,\n\t\t\t\t\tstart: entry.timestamp - this.parser.pull.timestamp,\n\t\t\t\t})\n\t\t\trow.addItem(item)\n\t\t}\n\t}\n\n\tprivate getCooldownDuration(entry: CooldownHistoryEntry) {\n\t\tlet duration = entry.end - entry.start\n\n\t\t// If the cooldown expired naturally, it _may_ have a cast time greater than its cooldown.\n\t\tif (entry.endReason === CooldownEndReason.EXPIRED) {\n\t\t\tconst castTime = this.castTime.forAction(entry.action.id, entry.start) ?? 0\n\n\t\t\t// We add the animation lock constant to the cast time to mimic the game's\n\t\t\t// behaviour - also sometimes known as \"caster tax\".\n\t\t\tduration = Math.max(duration, castTime + ANIMATION_LOCK)\n\t\t}\n\n\t\treturn duration\n\t}\n}\n\nclass ChargeGainItem extends BaseItem {\n\tContent = () => (\n\t\t<div className={styles.chargeGain}>\n\t\t\t<Icon name=\"angle double up\" className={styles.icon}/>\n\t\t</div>\n\t)\n}\n","// extracted by mini-css-extract-plugin\nexport default {\"backgroundColour\":\"rgba(213, 221, 246, .4)\",\"chargeColor\":\"color(rgba(213, 221, 246, .4) a(100%) l(-20%))\",\"cooldown\":\"ActionTimeline-module_cooldown__3u1x3\",\"chargeGain\":\"ActionTimeline-module_chargeGain__3-Of9\",\"icon\":\"ActionTimeline-module_icon__8OvsF\"};","import {Trans} from '@lingui/react'\nimport {Action} from 'data/ACTIONS'\nimport {ANIMATION_LOCK} from 'data/CONSTANTS'\nimport {Event, Events} from 'event'\nimport {Analyser} from 'parser/core/Analyser'\nimport {filter} from 'parser/core/filter'\nimport {dependency} from 'parser/core/Injectable'\nimport CastTime from 'parser/core/modules/CastTime'\nimport Checklist, {Requirement, Rule} from 'parser/core/modules/Checklist'\nimport {Data} from 'parser/core/modules/Data'\nimport Downtime from 'parser/core/modules/Downtime'\nimport {GlobalCooldown} from 'parser/core/modules/GlobalCooldown'\nimport {SpeedAdjustments} from 'parser/core/modules/SpeedAdjustments'\nimport React from 'react'\n\nconst UPTIME_TARGET = 98\n\nexport class AlwaysBeCasting extends Analyser {\n\tstatic override handle = 'abc'\n\tstatic override debug = false\n\n\t@dependency protected castTime!: CastTime\n\t@dependency protected checklist!: Checklist\n\t@dependency protected data!: Data\n\t@dependency protected downtime!: Downtime\n\t@dependency protected globalCooldown!: GlobalCooldown\n\t@dependency protected speedAdjustments!: SpeedAdjustments\n\n\tprotected gcdUptimeSuggestionContent: JSX.Element = <Trans id=\"core.always-cast.description\">\n\t\tMake sure you're always doing something. It's often better to make small\n\t\tmistakes while keeping the GCD rolling than it is to perform the correct\n\t\trotation slowly.\n\t</Trans>\n\n\tprotected gcdUptime: number = 0\n\tprotected gcdsCounted: number = 0\n\n\tprivate lastBeginCast?: Events['prepare']\n\n\toverride initialise() {\n\t\tthis.addEventHook(\n\t\t\tfilter<Event>().source(this.parser.actor.id).type('prepare'),\n\t\t\tthis.onBeginCast\n\t\t)\n\t\tthis.addEventHook(\n\t\t\tfilter<Event>().source(this.parser.actor.id).type('action'),\n\t\t\tthis.onCast\n\t\t)\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\tprivate onBeginCast(event: Events['prepare']) {\n\t\tthis.lastBeginCast = event\n\t}\n\n\tprivate onCast(event: Events['action']) {\n\t\tconst action = this.data.getAction(event.action)\n\n\t\tif (action == null || action.onGcd == null || !action.onGcd) {\n\t\t\treturn\n\t\t}\n\n\t\tlet castTime = this.castTime.forEvent(event) ?? 0\n\t\tconst adjustedBaseGCD = this.globalCooldown.getDuration()\n\t\tif (castTime >= adjustedBaseGCD) {\n\t\t\t// Account for \"caster tax\" - animation lock on spells with cast time equal to or greater than the GCD that prevents starting the next spell until the animation finishes\n\t\t\tcastTime += ANIMATION_LOCK\n\t\t}\n\t\tconst recastTime = this.castTime.recastForEvent(event) ?? 0\n\n\t\tconst castStart = (this.lastBeginCast != null && this.lastBeginCast.action === event.action) ? this.lastBeginCast.timestamp : event.timestamp\n\t\tif (this.considerCast(action, castStart)) {\n\t\t\tconst relativeTimestamp = event.timestamp - this.parser.pull.timestamp\n\t\t\tif (castTime > relativeTimestamp) {\n\t\t\t\tthis.debug(`GCD Uptime for precast ${action.name} at ${this.parser.formatEpochTimestamp(event.timestamp, 1)} - Cast time: ${castTime} | Recast time: ${recastTime} | Time of completion: ${relativeTimestamp}`)\n\t\t\t\tthis.gcdUptime += Math.max(0, relativeTimestamp)\n\t\t\t} else {\n\t\t\t\tthis.debug(`GCD Uptime for ${action.name} at ${this.parser.formatEpochTimestamp(event.timestamp, 1)} - Cast time: ${castTime} | Recast time: ${recastTime}`)\n\t\t\t\tthis.gcdUptime += Math.max(castTime, recastTime)\n\t\t\t}\n\t\t\tthis.gcdsCounted += 1\n\t\t} else {\n\t\t\tthis.debug(`Excluding cast of ${action.name} at ${this.parser.formatEpochTimestamp(event.timestamp, 1)}`)\n\t\t}\n\t\tthis.lastBeginCast = undefined\n\t}\n\n\t/**\n\t * Implementing modules MAY override this to return false and exclude certain events from GCD uptime calculations.\n\t * By default, returns true if the cast did not start during downtime\n\t * @param action Action being considered for GCD uptime\n\t * @param timestamp Timestamp the action occurred at\n\t * @param castTime Calculated cast time of the action (adjusted by speed modifiers, if any active)\n\t */\n\tprotected considerCast(_action: Action, castStart: number) {\n\t\treturn !this.downtime.isDowntime(castStart)\n\t}\n\n\tprotected getUptimePercent(): number {\n\t\tthis.debug(`Observed ${this.gcdsCounted} GCDs for a total of ${this.gcdUptime} ms of uptime`)\n\t\tconst fightDuration = this.parser.currentDuration - this.downtime.getDowntime()\n\t\tconst uptime = this.gcdUptime / fightDuration * 100\n\t\tthis.debug(`Total fight duration: ${this.parser.currentDuration} - Downtime: ${this.downtime.getDowntime()} - Uptime percentage ${uptime}`)\n\t\treturn uptime\n\t}\n\n\tprotected onComplete() {\n\t\tif (this.gcdUptime === 0) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.checklist.add(new Rule({\n\t\t\tname: <Trans id=\"core.always-cast.title\">Always be casting</Trans>,\n\t\t\tdescription: this.gcdUptimeSuggestionContent,\n\t\t\tdisplayOrder: -1,\n\t\t\trequirements: [\n\t\t\t\tnew Requirement({\n\t\t\t\t\tname: <Trans id=\"core.always-cast.gcd-uptime\">GCD Uptime</Trans>,\n\t\t\t\t\tpercent: this.getUptimePercent(),\n\t\t\t\t}),\n\t\t\t],\n\t\t\ttarget: UPTIME_TARGET,\n\t\t}))\n\t}\n}\n","import {Status} from 'data/STATUSES'\nimport {Event, Events} from 'event'\nimport {Analyser} from 'parser/core/Analyser'\nimport {filter, oneOf} from 'parser/core/filter'\nimport {dependency} from 'parser/core/Injectable'\nimport {Actor, Actors} from 'parser/core/modules/Actors'\nimport {Data} from 'parser/core/modules/Data'\nimport {Invulnerability} from 'parser/core/modules/Invulnerability'\nimport {Statuses} from 'parser/core/modules/Statuses'\n\nconst MILLISECONDS_PER_MINUTE = 60000\n\ntype DotTracking = Map<Status['id'], Map<Actor['id'], DotTargetTracking>>\ninterface DotTargetTracking {\n\tlastApplied: number\n\ttotalClipping: number\n}\n\nexport abstract class DoTs extends Analyser {\n\tstatic override handle = 'dots'\n\n\t@dependency protected data!: Data\n\t@dependency private actors!: Actors\n\t@dependency private invulnerability!: Invulnerability\n\t@dependency private statuses!: Statuses\n\n\t/** Implementing modules MUST override this with a list of Status IDs. */\n\tprotected abstract trackedStatuses: number[] = []\n\n\tprivate statusApplications: DotTracking = new Map<number, Map<string, DotTargetTracking>>()\n\n\toverride initialise() {\n\t\tthis.addEventHook(\n\t\t\tfilter<Event>()\n\t\t\t\t.type('statusApply')\n\t\t\t\t.source(this.parser.actor.id)\n\t\t\t\t.status(oneOf(this.trackedStatuses)),\n\t\t\tthis.onApply,\n\t\t)\n\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\t/**\n\t * Implementing modules MUST override this to configure the checklist.\n\t * This should be handled on a job-by-job basis rather than generically, since the description\n\t * text isn't one-size-fits-all, and some jobs may have custom targets.\n\t */\n\tprotected abstract addChecklistRules(): void\n\n\t/**\n\t * Implementing modules MUST override this to configure suggestions.\n\t * This should be handled on a job-by-job basis rather than generically, since different jobs have\n\t * different thresholds for what constitutes bad clipping with varying explanations as to why.\n\t */\n\tprotected abstract addClippingSuggestions(): void\n\n\t/**\n\t * Implementing modules can optionally exclude applications of a status from clipping calculations.\n\t * (e.g. SMN rushing)\n\t */\n\tprotected excludeApplication() {\n\t\treturn false\n\t}\n\n\tprivate onApply(event: Events['statusApply']) {\n\t\tconst status = this.data.getStatus(event.status)\n\t\t// Cannot track for statuses that are not defined with a duration\n\t\tif (status?.duration == null) { return }\n\n\t\t// Get the tracking object for this status\n\t\tlet trackedStatus = this.statusApplications.get(status.id)\n\t\tif (trackedStatus == null) {\n\t\t\ttrackedStatus = new Map<string, DotTargetTracking>()\n\t\t\tthis.statusApplications.set(status.id, trackedStatus)\n\t\t}\n\n\t\t// Get the tracking object for this status on this target\n\t\tconst target = event.target\n\t\tlet trackedStatusOnTarget = trackedStatus.get(target)\n\t\tif (trackedStatusOnTarget == null) {\n\t\t\ttrackedStatusOnTarget = {lastApplied: 0, totalClipping: 0}\n\t\t\ttrackedStatus.set(target, trackedStatusOnTarget)\n\t\t}\n\n\t\t// If it's not been applied yet or should be excluded per job-specific logic (if any), set it and skip out\n\t\tif (trackedStatusOnTarget.lastApplied === 0 || this.excludeApplication()) {\n\t\t\ttrackedStatusOnTarget.lastApplied = event.timestamp\n\t\t\treturn\n\t\t}\n\n\t\t// Base clip calc\n\t\tconst clip = status.duration - (event.timestamp - trackedStatusOnTarget.lastApplied)\n\t\t// Cap clip at 0 - less than that is downtime, which is handled by the checklist requirement\n\t\ttrackedStatusOnTarget.totalClipping += Math.max(0, clip)\n\t\ttrackedStatusOnTarget.lastApplied = event.timestamp\n\t}\n\n\tprivate onComplete() {\n\t\tthis.addChecklistRules()\n\t\tthis.addClippingSuggestions()\n\t}\n\n\t// These two functions are helpers for submodules and should be used but not overridden\n\tprotected getUptimePercent(statusId: number) {\n\t\tconst status = this.data.getStatus(statusId)\n\t\tif (status == null) { return 0 }\n\n\t\tconst statusUptime = this.statuses.getUptime(status, this.actors.foes)\n\t\tconst fightDuration = this.parser.pull.duration - this.invulnerability.getDuration({types: ['invulnerable']})\n\t\treturn (statusUptime / fightDuration) * 100\n\t}\n\n\t// This normalises clipping as milliseconds clipped per minute,\n\t// since some level of clipping is expected and we need tiers that work for both long and short fights\n\tprotected getClippingAmount(statusId: number) {\n\t\tconst fightDuration = (this.parser.pull.duration - this.invulnerability.getDuration({types: ['invulnerable']}))\n\t\tif (fightDuration <= 0) { return 0 }\n\n\t\tconst statusApplications = this.statusApplications.get(statusId)\n\t\tif (statusApplications == null) { return 0 }\n\n\t\tconst totalClipping = Array.from(statusApplications.values()).reduce((clip, target) => clip + target.totalClipping, 0)\n\t\tconst clipMSPerMin = Math.round(totalClipping / (fightDuration / MILLISECONDS_PER_MINUTE))\n\t\treturn clipMSPerMin\n\t}\n}\n","import {MessageDescriptor} from '@lingui/core'\nimport {t} from '@lingui/macro'\nimport {Trans} from '@lingui/react'\nimport TransMarkdown from 'components/ui/TransMarkdown'\nimport {BASE_GCD} from 'data/CONSTANTS'\nimport React from 'react'\nimport {Report} from 'report'\nimport {Analyser} from '../Analyser'\nimport {dependency} from '../Injectable'\nimport {Data} from './Data'\nimport {SpeedAdjustments} from './SpeedAdjustments'\nimport {SimpleStatistic, Statistics} from './Statistics'\n\nconst estimateHelp: Record<Report['meta']['source'] | '__all', MessageDescriptor> = {\n\t__all: t('core.gcd.no-statistics.v2')`This GCD recast is an *estimate*, and may be incorrect. If it is reporting a GCD recast *longer* than reality, you likely need to focus on keeping your GCD rolling.`,\n\tlegacyFflogs: t('core.gcd.estimate-help.fflogs')`Precise attribute values are only available from FF Logs for the player who logged the report in ACT.`,\n}\n\nexport class GlobalCooldown extends Analyser {\n\tstatic override handle = 'gcd'\n\n\t@dependency private data!: Data\n\t@dependency private statistics!: Statistics\n\t@dependency private speedAdjustments!: SpeedAdjustments\n\n\toverride initialise() {\n\t\tthis.addEventHook('complete', this.onComplete)\n\t}\n\n\t/**\n\t * Get the base recast time of the parsed actor's GCD cooldown group, in milliseconds.\n\t * The value returned from this function _may_ be an estimate - check {@link GlobalCooldown.isEstimated}\n\t * to see if it is.\n\t */\n\tpublic getDuration() {\n\t\treturn this.speedAdjustments.getAdjustedDuration({duration: BASE_GCD})\n\t}\n\n\t/** Returns whether the GCD duration calculated by this module is an estimate. */\n\tpublic isEstimated() {\n\t\treturn this.speedAdjustments.isAdjustmentEstimated()\n\t}\n\n\tprivate onComplete() {\n\t\tconst estimated = this.isEstimated()\n\n\t\tthis.statistics.add(new SimpleStatistic({\n\t\t\ttitle: estimated\n\t\t\t\t? <Trans id=\"core.gcd.estimated-gcd\">Estimated GCD</Trans>\n\t\t\t\t: <Trans id=\"core.gcd.gcd\">GCD Recast</Trans>,\n\t\t\ticon: this.data.actions.ATTACK.icon,\n\t\t\tvalue: this.parser.formatDuration(this.getDuration()),\n\t\t\tinfo: estimated ? <>\n\t\t\t\t<TransMarkdown source={estimateHelp.__all}/>\n\t\t\t\t<TransMarkdown source={estimateHelp[this.parser.report.meta.source]}/>\n\t\t\t</> : undefined,\n\t\t}))\n\t}\n}\n","import {Status, StatusKey} from 'data/STATUSES'\nimport {Events} from 'event'\nimport {ensureArray} from 'utilities'\nimport {Analyser} from '../Analyser'\nimport {dependency} from '../Injectable'\nimport {Actor, StatusEvent} from './Actors'\nimport {Data} from './Data'\nimport {Invulnerability} from './Invulnerability'\n\ninterface Edge {\n\tside: 'apply' | 'remove'\n\ttimestamp: number\n}\n\nexport class Statuses extends Analyser {\n\tstatic override handle = 'statuses'\n\tstatic override debug = false\n\n\t@dependency private readonly data!: Data\n\t@dependency private readonly invulnerability!: Invulnerability\n\n\t/**\n\t * Calculate the total uptime of the specified status across allspecified actors.\n\t * @param statusSpecifier Status to calculate uptime of.\n\t * @param targetSpecifier Target(s) that should be checked for the status.\n\t * @param source Source of statuses to filter by. Defaults to the parsed actor.\n\t */\n\tgetUptime(\n\t\tstatusSpecifier: StatusKey | Status,\n\t\ttargetSpecifier: Actor | Actor[],\n\t\tsource = this.parser.actor\n\t) {\n\t\t// Resolve arguments.\n\t\tconst status = typeof statusSpecifier === 'string'\n\t\t\t? this.data.statuses[statusSpecifier]\n\t\t\t: statusSpecifier\n\n\t\tconst targets = ensureArray(targetSpecifier)\n\n\t\t// Collect all the status history for the specified status/target/source combo.\n\t\tconst edges = targets.flatMap(target => this.edgesForActor(\n\t\t\ttarget,\n\t\t\ttarget.statusHistory.get(status.id)?.get(source.id) ?? []\n\t\t))\n\n\t\t// Edges are mapped from multiple potential targets; interlace by sorting by timestamp.\n\t\tedges.sort((a, b) => a.timestamp - b.timestamp)\n\n\t\t// Sum time when any of the specified targets had the status.\n\t\tconst meta = {uptime: 0, depth: 0, application: 0}\n\t\tfor (const edge of edges) {\n\t\t\tif (edge.side === 'apply') {\n\t\t\t\tif (meta.depth === 0) {\n\t\t\t\t\tmeta.application = edge.timestamp\n\t\t\t\t}\n\t\t\t\tmeta.depth ++\n\n\t\t\t} else {\n\t\t\t\tmeta.depth --\n\t\t\t\tif (meta.depth === 0) {\n\t\t\t\t\tmeta.uptime += edge.timestamp - meta.application\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.debug(`Status ${status.name} ${edge.side} at ${this.ft(edge.timestamp)}, depth=${meta.depth}`)\n\t\t}\n\n\t\treturn meta.uptime\n\t}\n\n\tprivate edgesForActor(target: Actor, events: StatusEvent[]) {\n\t\t// We can safely assume status events from an actor will alternate between apply and remove.\n\t\tconst edges: Edge[] = []\n\t\tlet apply: Events['statusApply'] | undefined\n\t\tlet refresh: Events['statusApply'] | undefined\n\n\t\tfor (const event of events) {\n\t\t\t// Track the initial application and refreshes.\n\t\t\tif (event.type === 'statusApply') {\n\t\t\t\tapply ??= event\n\t\t\t\trefresh = event\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (apply == null) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Window has been closed, merge any edges in.\n\t\t\tedges.push(...this.splitRangeForInvulns(\n\t\t\t\ttarget,\n\t\t\t\tapply.timestamp,\n\t\t\t\tevent.timestamp\n\t\t\t))\n\t\t\tapply = undefined\n\t\t}\n\n\t\t// If we've got a dangling apply, build edges for it.\n\t\tif (apply != null) {\n\t\t\t// Try to find a reasonable remove time for the status, if it has a duration.  Cap to the end of the fight.\n\t\t\tconst statusDuration = this.data.getStatus(apply.status)?.duration\n\t\t\tconst remove = statusDuration == null\n\t\t\t\t? this.parser.currentEpochTimestamp\n\t\t\t\t: Math.min((refresh ?? apply).timestamp + statusDuration, this.parser.currentEpochTimestamp)\n\n\t\t\tedges.push(...this.splitRangeForInvulns(\n\t\t\t\ttarget,\n\t\t\t\tapply.timestamp,\n\t\t\t\tremove,\n\t\t\t))\n\t\t}\n\n\t\treturn edges\n\t}\n\n\tprivate splitRangeForInvulns(target: Actor, apply: number, remove: number): Edge[] {\n\t\tlet range = {apply, remove}\n\t\tconst finalRanges = [range]\n\n\t\t// Get the invuln windows that occured during this range\n\t\tconst invulns = this.invulnerability.getWindows({\n\t\t\tstart: apply,\n\t\t\tend: remove,\n\t\t\tactorFilter: actor => actor.kind === target.kind,\n\t\t\ttypes: ['invulnerable'],\n\t\t})\n\n\t\tfor (const invuln of invulns) {\n\t\t\t// Invuln clipped start of range.\n\t\t\tif (invuln.start < range.apply && invuln.end >= range.apply) {\n\t\t\t\tthis.debug(`Start clip, [${this.ft(range.apply)},${this.ft(range.remove)}] -> [${this.ft(invuln.end)},${this.ft(range.remove)}]`)\n\n\t\t\t\trange.apply = invuln.end\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Invuln clipped end of range.\n\t\t\tif (invuln.start <= range.remove && invuln.end > range.remove) {\n\t\t\t\tthis.debug(`End clip, [${this.ft(range.apply)},${this.ft(range.remove)}] -> [${this.ft(range.apply)},${this.ft(invuln.start)}]`)\n\n\t\t\t\trange.remove = invuln.start\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Everything else should be a range split, sanity check.\n\t\t\tif (invuln.start < range.apply || invuln.end > range.remove) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tthis.debug(`Split [${this.ft(range.apply)},${this.ft(range.remove)}] -> [${this.ft(range.apply)},${this.ft(invuln.start)}], [${this.ft(invuln.end)},${this.ft(range.remove)}]`)\n\n\t\t\t// Split the range into two around the invuln.\n\t\t\tconst previousRange = range\n\t\t\trange = {...range}\n\t\t\tfinalRanges.push(range)\n\n\t\t\tpreviousRange.remove = invuln.start\n\t\t\trange.apply = invuln.end\n\t\t}\n\n\t\t// Map the ranges into edges.\n\t\treturn finalRanges.flatMap(range => [\n\t\t\t{side: 'apply', timestamp: range.apply},\n\t\t\t{side: 'remove', timestamp: range.remove},\n\t\t] as const)\n\t}\n\n\t// Small utility for formatting timestamps, as we do it a _lot_ in debug messages\n\tprivate ft = (timestamp: number) => this.parser.formatEpochTimestamp(timestamp, 1)\n}\n","import {ActionRow, ActionTimeline as CoreActionTimeline} from 'parser/core/modules/ActionTimeline'\n\nexport class ActionTimeline extends CoreActionTimeline {\n\tstatic override rows: ActionRow[] = [\n\t\t...CoreActionTimeline.rows,\n\t\t'BARRAGE',\n\t\t'RAGING_STRIKES',\n\t\t'BATTLE_VOICE',\n\t\t'RADIANT_FINALE',\n\t\t'BLOODLETTER',\n\t\t{\n\t\t\tlabel: 'Songs',\n\t\t\tcontent: [\n\t\t\t\t'THE_WANDERERS_MINUET',\n\t\t\t\t'MAGES_BALLAD',\n\t\t\t\t'ARMYS_PAEON',\n\t\t\t],\n\t\t},\n\t\t'EMPYREAL_ARROW',\n\t\t'SIDEWINDER',\n\t\t'PITCH_PERFECT',\n\t\t'TROUBADOUR',\n\t\t'NATURES_MINNE',\n\t\t'THE_WARDENS_PAEAN',\n\t\t'REPELLING_SHOT',\n\t]\n}\n","import {Action} from 'data/ACTIONS'\nimport {Event, Events} from 'event'\nimport {filter, oneOf} from 'parser/core/filter'\nimport {AlwaysBeCasting as CoreAlwaysBeCasting} from 'parser/core/modules/AlwaysBeCasting'\n\ninterface ArmyWindow {\n\tstart: number\n\tend: number\n}\n\nexport class AlwaysBeCasting extends CoreAlwaysBeCasting {\n\tprivate armyHistory: ArmyWindow[] = []\n\tprivate currentArmy: ArmyWindow | undefined = undefined\n\n\toverride initialise() {\n\t\tsuper.initialise()\n\n\t\tconst armyFilter = filter<Event>()\n\t\t\t.source(this.parser.actor.id)\n\t\t\t.status(oneOf([this.data.statuses.ARMYS_MUSE.id, this.data.statuses.ARMYS_PAEON.id]))\n\n\t\tthis.addEventHook(armyFilter.type('statusApply'), this.onApplyArmy)\n\t\tthis.addEventHook(armyFilter.type('statusRemove'), this.onRemoveArmy)\n\t}\n\n\tprivate onApplyArmy(event: Events['statusApply']) {\n\t\tif (this.currentArmy != null) { return }\n\n\t\tthis.currentArmy = {\n\t\t\tstart: event.timestamp,\n\t\t\tend: this.parser.pull.timestamp + this.parser.pull.duration,\n\t\t}\n\n\t\tthis.armyHistory.push(this.currentArmy)\n\t}\n\n\tprivate onRemoveArmy(event: Events['statusRemove']) {\n\t\tif (this.currentArmy != null) {\n\t\t\tthis.currentArmy.end = event.timestamp\n\t\t\tthis.currentArmy = undefined\n\t\t}\n\t}\n\n\toverride considerCast(action: Action, castStart: number): boolean {\n\t\t// Because Army's Paeon and Army's Muse reduce GCD speed by a variable amount that we can't synthesize, we exclude skills used under either buff from GCD uptime analysis\n\t\tif (this.currentArmy != null)  {\n\t\t\tthis.debug(`Army's buff active at ${this.parser.formatEpochTimestamp(castStart)}`)\n\t\t\treturn false\n\t\t}\n\n\t\treturn super.considerCast(action, castStart)\n\t}\n\n\toverride getUptimePercent(): number {\n\t\tthis.debug(`Observed ${this.gcdsCounted} GCDs for a total of ${this.gcdUptime} ms of uptime`)\n\t\tconst fightDuration = this.parser.currentDuration - this.downtime.getDowntime()\n\t\tconst armyDuration = this.armyHistory.reduce((acc, army) => {\n\t\t\tconst downtime = this.downtime.getDowntime(\n\t\t\t\tarmy.start,\n\t\t\t\tarmy.end,\n\t\t\t)\n\t\t\treturn acc + army.end - army.start - downtime\n\t\t}, 0)\n\t\t// Because Army's Paeon and Army's Muse reduce GCD speed by a variable amount that we can't synthesize, we exclude time under either buff from GCD uptime analysis\n\t\tconst uptime = this.gcdUptime / (fightDuration - armyDuration) * 100\n\t\tthis.debug(`Total fight duration: ${this.parser.currentDuration} - Downtime: ${this.downtime.getDowntime()} - Army's Paeon or Muse active: ${armyDuration} - Uptime percentage ${uptime}`)\n\n\t\treturn uptime\n\t}\n}\n","import {Trans} from '@lingui/react'\nimport {ActionLink, StatusLink} from 'components/ui/DbLink'\nimport {dependency} from 'parser/core/Injectable'\nimport Checklist, {Requirement, TARGET, TieredRule} from 'parser/core/modules/Checklist'\nimport {DoTs as CoreDoTs} from 'parser/core/modules/DoTs'\nimport Suggestions, {SEVERITY, TieredSuggestion} from 'parser/core/modules/Suggestions'\nimport React from 'react'\n\n// Bard clips ~15s every 120s rotationally\nconst SEVERITIES = {\n\tCLIPPING: {\n\t\t10000: SEVERITY.MINOR,\n\t\t15000: SEVERITY.MEDIUM,\n\t\t20000: SEVERITY.MAJOR,\n\t},\n\tUPTIME: {\n\t\t85: TARGET.WARN,\n\t\t95: TARGET.SUCCESS,\n\t},\n}\n\nexport class DoTs extends CoreDoTs {\n\t@dependency private checklist!: Checklist\n\t@dependency private suggestions!: Suggestions\n\n\tprotected override trackedStatuses = [\n\t\tthis.data.statuses.CAUSTIC_BITE.id,\n\t\tthis.data.statuses.STORMBITE.id,\n\t]\n\n\tprotected override addChecklistRules() {\n\t\tthis.checklist.add(new TieredRule({\n\t\t\tname: <Trans id=\"brd.dots.checklist.name\">Keep your DoTs up</Trans>,\n\t\t\tdescription: <Trans id=\"brd.dots.checklist.description\">A significant amount of Bard's DPS comes from <ActionLink {...this.data.actions.CAUSTIC_BITE}/> and <ActionLink {...this.data.actions.STORMBITE}/>.\n\t\t\t\tMake sure you have these skills applied on the target at all times. Use <ActionLink {...this.data.actions.IRON_JAWS}/> to refresh the timer on the Damage over Time (DoT) debuff.\n\t\t\t</Trans>,\n\t\t\ttiers: SEVERITIES.UPTIME,\n\t\t\trequirements: [\n\t\t\t\tnew Requirement({\n\t\t\t\t\tname: <Trans id=\"brd.dots.checklist.requirement.caustic\"><StatusLink {...this.data.statuses.CAUSTIC_BITE} /> uptime</Trans>,\n\t\t\t\t\tpercent: () => this.getUptimePercent(this.data.statuses.CAUSTIC_BITE.id),\n\t\t\t\t}),\n\t\t\t\tnew Requirement({\n\t\t\t\t\tname: <Trans id=\"brd.dots.checklist.requirement.storm\"><StatusLink {...this.data.statuses.STORMBITE} /> uptime</Trans>,\n\t\t\t\t\tpercent: () => this.getUptimePercent(this.data.statuses.STORMBITE.id),\n\t\t\t\t}),\n\t\t\t],\n\t\t}))\n\t}\n\n\tprotected addClippingSuggestions() {\n\t\t// DoTs are meant to be refreshed together, so just average their clip\n\t\tconst meanClip = (this.getClippingAmount(this.data.statuses.CAUSTIC_BITE.id) + this.getClippingAmount(this.data.statuses.STORMBITE.id)) / 2\n\n\t\tthis.suggestions.add(new TieredSuggestion({\n\t\t\ticon: this.data.actions.IRON_JAWS.icon,\n\t\t\tcontent: <Trans id=\"brd.dots.suggestion.clip.content\">\n\t\t\t\t\tAvoid refreshing <ActionLink {...this.data.actions.CAUSTIC_BITE} /> and <ActionLink {...this.data.actions.STORMBITE} /> significantly before they expire.\n\t\t\t</Trans>,\n\t\t\twhy: <Trans id=\"brd.dots.suggestion.clip.why\">\n\t\t\t\t\t\tAn average of {this.parser.formatDuration(meanClip)} of DoTs clipped per minute due to early refreshes.\n\t\t\t</Trans>,\n\t\t\ttiers: SEVERITIES.CLIPPING,\n\t\t\tvalue: meanClip,\n\t\t}))\n\t}\n}\n","//                     Lv.89 DRIFTING EA\n//\n//                          ``......`\n//                 `-:+sydmNNNNNNNNNNNmdys+:.\n//             .:ohmNMMMMMMMMMMMMMMMMMMMMMMMNmy+-\n//          .+hNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNdo.\n//       `:hNMMMMMMMMMMMMMMMMMMMMMMMMMMNmmmNMMMMMMMNy-\n//      /dMMMMMMMMMMMMMMMMMMMMMMMMMMms:-....:ohNMMMMMNs.\n//    .yMMMMMMMMMMMMMMMMMMMMMMMMMMMs.          .omMMMMMm/\n//   -mMMMMMMMMMMMMMMMMMMMMMMMMMMMs          --. .sNMMMMMs`\n//  .mMMMMMMMMMMMMMMMMMMMMMMMMMMMM. yhy:    :MMNs  :NMMMMMy`\n//  hMMMMMMMMMMMMMMMMMMMMMMMMMMMMM. mMMM:   `hMMM.  :MMMMMMo\n// -MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMo .yNN/    `:o+    sMMMMMM-\n// oMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM/  ``             .MMMMMMy\n// sMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMs`                dMMMMMM`\n// +MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMm-               sMMMMMM:\n// .MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMo              /MMMMMM+\n//  hMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMh`            :MMMMMMo\n//  .MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMd.           -MMMMMM:\n//   +MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMd`          -MMMMMN`\n//    yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMh          -MMMMMo\n//    `dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM/         -MMMMN.\n//     .mMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMo         .MMMMy\n//      -NMMMMMMMMMMMMMMMMMyNMMMMMMMMMMMMMMM:         .MMMM:\n//       :NMMMMMMMMMMMMMMMMd-hMMMMdoMMMMMMMN`         `MMMM`\n//        /NMMMMMMMhhMMMMMMM/`:so:` NMMMMMMd           NMMN\n//         /NMMMMMMy /mMN++hd`      oMMMMMMm           yMMM\n//          /NMMMMMo  `+h   .`       +NMMMMM/          -MMM`\n//           +MMMMM-                  .sNMMMN-          +MM:\n//            dMMM+                     .omMMm.          +Ns\n//            :Mm:                         :smm-          ./\n//             /                              -+-\n\nimport {t} from '@lingui/macro'\nimport {Trans} from '@lingui/react'\nimport Tooltip, {ActionLink} from 'components/ui/DbLink'\nimport {Event, Events} from 'event'\nimport {Analyser} from 'parser/core/Analyser'\nimport {filter} from 'parser/core/filter'\nimport {dependency} from 'parser/core/Injectable'\nimport {Data} from 'parser/core/modules/Data'\nimport Downtime from 'parser/core/modules/Downtime'\nimport {Timeline} from 'parser/core/modules/Timeline'\nimport React, {Fragment} from 'react'\nimport {Button, Message, Table} from 'semantic-ui-react'\n\n// Buffer (ms) to forgive insignificant drift\nconst DRIFT_BUFFER = 2000\n\n// Buffer (ms) to allow for reopeners after a downtime\nconst REOPENER_BUFFER = 4000\nconst MIN_REOPENER_DOWNTIME = 15000\n\n// Timeline padding to see the drifted oGCD when you jump to the window\nconst TIMELINE_PADDING = 2500\n\ninterface DriftWindow {\n\tstart: number\n}\n\ninterface ConfirmedDriftWindow extends DriftWindow {\n\tdriftedActionId: number\n\tdrift: number\n\tend: number\n}\n\nexport class DriftingEa extends Analyser {\n\tstatic override handle = 'drifting-ea'\n\tstatic override title = t('brd.drifting-ea.title')`Empyreal Arrow Drift`\n\n\t@dependency private data!: Data\n\t@dependency private downtime!: Downtime\n\t@dependency private timeline!: Timeline\n\n\tprivate driftedWindows: ConfirmedDriftWindow[] = []\n\n\tprivate currentWindow: DriftWindow =  {\n\t\tstart: this.parser.pull.timestamp,\n\t}\n\n\toverride initialise() {\n\t\tconst eaId = this.data.actions.EMPYREAL_ARROW.id\n\n\t\tconst castFilter = filter<Event>()\n\t\t\t.type('action')\n\t\t\t.source(this.parser.actor.id)\n\n\t\tthis.addEventHook(castFilter.action(eaId), this.onDriftableCast)\n\t}\n\n\tprivate onDriftableCast(event: Events['action']) {\n\t\tconst action = this.data.getAction(event.action)\n\n\t\tif (!action || !action.cooldown) { return }\n\n\t\tconst window = this.currentWindow\n\t\tconst observedUseTime = event.timestamp\n\n\t\t// Cap at this event's timestamp, just in case\n\t\tconst earliestUseTime = Math.min(window.start + action.cooldown, observedUseTime)\n\n\t\tlet expectedUseTime = earliestUseTime\n\n\t\t// Increase the expected use time if it was in downtime\n\t\tif (this.downtime.isDowntime(earliestUseTime)) {\n\t\t\tconst downtimeWindow = this.downtime.getDowntimeWindows(window.start, observedUseTime)[0]\n\t\t\texpectedUseTime = downtimeWindow.end\n\n\t\t\t// Forgive \"drift\" due to reopening with other actions after downtime\n\t\t\tif (downtimeWindow.end - downtimeWindow.start > MIN_REOPENER_DOWNTIME) {\n\t\t\t\texpectedUseTime += REOPENER_BUFFER\n\t\t\t}\n\t\t}\n\n\t\tconst drift = Math.max(0, observedUseTime - expectedUseTime)\n\n\t\t// Forgive a small amount of drift\n\t\tif (drift > DRIFT_BUFFER) {\n\t\t\tthis.driftedWindows.push({\n\t\t\t\t...window,\n\t\t\t\tdriftedActionId: event.action,\n\t\t\t\tdrift: drift,\n\t\t\t\tend: observedUseTime,\n\t\t\t})\n\t\t}\n\n\t\t// Begin the next window\n\t\tthis.currentWindow = {\n\t\t\tstart: observedUseTime,\n\t\t}\n\t}\n\n\toverride output() {\n\t\t// Nothing to show\n\t\tif (!this.driftedWindows.length) { return }\n\n\t\tconst driftTable = <Table collapsing unstackable compact=\"very\">\n\t\t\t<Table.Header>\n\t\t\t\t<Table.Row>\n\t\t\t\t\t<Table.HeaderCell><Trans id=\"brd.drifting-ea.timestamp-header\">Timestamp</Trans></Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell><Trans id=\"brd.drifting-ea.drift-header\">Drift Issue</Trans></Table.HeaderCell>\n\t\t\t\t\t<Table.HeaderCell></Table.HeaderCell>\n\t\t\t\t</Table.Row>\n\t\t\t</Table.Header>\n\t\t\t<Table.Body>\n\t\t\t\t{this.driftedWindows.map(window => {\n\t\t\t\t\treturn <Table.Row key={window.start}>\n\t\t\t\t\t\t<Table.Cell>{this.parser.formatEpochTimestamp(window.end)}</Table.Cell>\n\t\t\t\t\t\t<Table.Cell>\n\t\t\t\t\t\t\t<Trans id=\"brd.drifting-ea.drift-issue\">\n\t\t\t\t\t\t\t\t<ActionLink {...this.data.getAction(window.driftedActionId)}/> drifted by {this.parser.formatDuration(window.drift)}\n\t\t\t\t\t\t\t</Trans>\n\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t\t<Table.Cell>\n\t\t\t\t\t\t\t<Button onClick={() =>\n\t\t\t\t\t\t\t\tthis.timeline.show(window.start - this.parser.pull.timestamp, window.end + TIMELINE_PADDING - this.parser.pull.timestamp)}>\n\t\t\t\t\t\t\t\t<Trans id=\"brd.drifting-ea.timelinelink-button\">Jump to Timeline</Trans>\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t</Table.Cell>\n\t\t\t\t\t</Table.Row>\n\t\t\t\t})}\n\t\t\t</Table.Body>\n\t\t</Table>\n\n\t\treturn <Fragment>\n\t\t\t<Message>\n\t\t\t\t<Trans id=\"brd.drifting-ea.accordion.message\">\n\t\t\t\t\t<ActionLink action=\"EMPYREAL_ARROW\"/> is your most valuable oGCD thanks to <Tooltip sheet=\"Trait\" id={169}/>, and should be used on cooldown.\n\t\t\t\t</Trans>\n\t\t\t</Message>\n\t\t\t{driftTable}\n\t\t</Fragment>\n\t}\n}\n","import {Defensives} from 'parser/core/modules/Defensives'\n\nexport class Mitigation extends Defensives {\n\tprotected override trackedDefensives = [\n\t\tthis.data.actions.NATURES_MINNE,\n\t\tthis.data.actions.TROUBADOUR,\n\t]\n}\n","import ACTIONS from 'data/ACTIONS'\nimport {AoEUsages} from 'parser/core/modules/AoEUsages'\nimport DISPLAY_ORDER from './DISPLAY_ORDER'\n\nexport class MultiHitSkills extends AoEUsages {\n\tstatic displayerOrder = DISPLAY_ORDER.MULTI_HIT_SKILLS\n\tsuggestionIcon = ACTIONS.LADONSBITE.icon\n\n\ttrackedActions = [\n\t\t{\n\t\t\taoeAction: ACTIONS.QUICK_NOCK,\n\t\t\tstActions: [ACTIONS.BURST_SHOT],\n\t\t\tminTargets: 2,\n\t\t}, {\n\t\t\taoeAction: ACTIONS.LADONSBITE,\n\t\t\tstActions: [ACTIONS.BURST_SHOT],\n\t\t\tminTargets: 2,\n\t\t}, {\n\t\t\taoeAction: ACTIONS.SHADOWBITE,\n\t\t\tstActions: [ACTIONS.BURST_SHOT],\n\t\t\tminTargets: 2,\n\t\t}, {\n\t\t\taoeAction: ACTIONS.RAIN_OF_DEATH,\n\t\t\tstActions: [ACTIONS.BLOODLETTER],\n\t\t\tminTargets: 2,\n\t\t},\n\t]\n}\n","export default {\n\tRAGING_STRIKES: 1,\n\tBARRAGE: 2,\n\tPITCH_PERFECT: 3,\n\tSIDEWINDER: 4,\n\tSNAPSHOTS: 5,\n\tMULTI_HIT_SKILLS: 6,\n}\n","/**\n * @author Yumiya\n */\nimport {CooldownDowntime} from 'parser/core/modules/CooldownDowntime'\n\nexport class OGCDDowntime extends CooldownDowntime {\n\toverride trackedCds = [\n\t\t{\n\t\t\tcooldowns: [this.data.actions.EMPYREAL_ARROW],\n\t\t\tfirstUseOffset: 4000,\n\t\t\tallowedAverageDowntime: 1,\n\t\t},\n\t\t{\n\t\t\tcooldowns: [this.data.actions.BATTLE_VOICE],\n\t\t\tfirstUseOffset: 7500,\n\t\t},\n\t\t{\n\t\t\tcooldowns: [this.data.actions.RADIANT_FINALE],\n\t\t\tfirstUseOffset: 7500,\n\t\t\tallowedAverageDowntime: 10000,\n\t\t},\n\t\t{\n\t\t\tcooldowns: [this.data.actions.RAGING_STRIKES],\n\t\t\tfirstUseOffset: 2500,\n\t\t},\n\t\t{\n\t\t\tcooldowns: [this.data.actions.BARRAGE],\n\t\t\tfirstUseOffset: 12000,\n\t\t},\n\t\t{\n\t\t\tcooldowns: [this.data.actions.SIDEWINDER],\n\t\t\tfirstUseOffset: 12000,\n\t\t},\n\t]\n}\n","import {t} from '@lingui/macro'\nimport {Plural, Trans} from '@lingui/react'\nimport {ActionLink, DataLink} from 'components/ui/DbLink'\nimport {RotationTargetOutcome} from 'components/ui/RotationTable'\nimport {Action, ActionKey} from 'data/ACTIONS'\nimport {Event, Events} from 'event'\nimport _ from 'lodash'\nimport {filter} from 'parser/core/filter'\nimport {dependency} from 'parser/core/Injectable'\nimport {\n\tBuffWindow,\n\tEvaluatedAction,\n\tEvaluationOutput,\n\tExpectedActionsEvaluator,\n\tExpectedActionGroupsEvaluator,\n\tExpectedGcdCountEvaluator,\n\tTrackedAction,\n\tTrackedActionsOptions,\n\tWindowEvaluator,\n} from 'parser/core/modules/ActionWindow'\nimport {HistoryEntry} from 'parser/core/modules/ActionWindow/History'\nimport {Actors} from 'parser/core/modules/Actors'\nimport {GlobalCooldown} from 'parser/core/modules/GlobalCooldown'\nimport {SEVERITY} from 'parser/core/modules/Suggestions'\nimport {SeverityTiers, TieredSuggestion} from 'parser/core/modules/Suggestions/Suggestion'\nimport React, {ReactNode} from 'react'\nimport {Team} from 'report'\nimport {Icon} from 'semantic-ui-react'\nimport {isDefined} from 'utilities'\nimport DISPLAY_ORDER from './DISPLAY_ORDER'\n\n// Minimum muse GCDs needed to expect an RS window to have 9 GCDs\nconst MIN_MUSE_GCDS = 3\n\nconst BUFF_BEST_USED_BEFORE_GCD = 3\n\nconst APEX_OPENER_BUFFER = 60000 // time it takes on average to fill the first Apex Arrow\n\nconst SUPPORT_ACTIONS: ActionKey[] = [\n\t'ARMS_LENGTH',\n\t'FOOT_GRAZE',\n\t'HEAD_GRAZE',\n\t'LEG_GRAZE',\n\t'NATURES_MINNE',\n\t'PELOTON',\n\t'REPELLING_SHOT',\n\t'SECOND_WIND',\n\t'SPRINT',\n\t'THE_WARDENS_PAEAN',\n\t'TROUBADOUR',\n]\n\ninterface MuseWindow {\n\tstart: number,\n\tend?: number | undefined,\n}\n\ninterface BarrageOptions extends TrackedActionsOptions {\n\tbarrageId: number\n\twasBarrageUsed: (window: HistoryEntry<EvaluatedAction[]>) => boolean\n}\n\nclass BarrageEvaluator extends ExpectedActionsEvaluator {\n\t// Because this class is not an Analyser, it cannot use Data directly\n\t// to get the id for Barrage, so it has to take it in here.\n\tprivate barrageId: number\n\tprivate wasBarrageUsed: (window: HistoryEntry<EvaluatedAction[]>) => boolean\n\n\tconstructor(opts: BarrageOptions) {\n\t\tsuper(opts)\n\t\tthis.barrageId = opts.barrageId\n\t\tthis.wasBarrageUsed = opts.wasBarrageUsed\n\t}\n\n\toverride countUsed(window: HistoryEntry<EvaluatedAction[]>, action: TrackedAction) {\n\t\tif (action.action.id === this.barrageId) {\n\t\t\treturn this.wasBarrageUsed(window) ? 1 : 0\n\t\t}\n\t\treturn super.countUsed(window, action)\n\t}\n}\n\ninterface BuffEvaluatorOptions {\n\tactions: Action[]\n\tgcdThreshold: number\n\n\tsuggestionIcon: string\n\tsuggestionContent: ReactNode\n\tseverityTiers: SeverityTiers\n}\n\nclass BuffEvaluator implements WindowEvaluator, BuffEvaluatorOptions {\n\tactions: Action[]\n\tgcdThreshold: number\n\n\tsuggestionIcon: string\n\tsuggestionContent: ReactNode\n\tsuggestionWhy: ReactNode\n\tseverityTiers: SeverityTiers\n\n\tconstructor(opt: BuffEvaluatorOptions) {\n\t\tthis.actions = opt.actions\n\t\tthis.gcdThreshold = opt.gcdThreshold\n\t\tthis.suggestionContent = opt.suggestionContent\n\t\tthis.suggestionIcon = opt.suggestionIcon\n\t\tthis.severityTiers = opt.severityTiers\n\t}\n\n\toutput(windows: Array<HistoryEntry<EvaluatedAction[]>>): EvaluationOutput[] {\n\t\treturn this.actions.map(it => {\n\t\t\tconst header = {\n\t\t\t\theader: <Trans id=\"brd.rs.rotation-table.header.on-time\"><ActionLink showName={false} {...it} /> On Time?</Trans>,\n\t\t\t\taccessor: it.name,\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tformat: 'notes',\n\t\t\t\theader: header,\n\t\t\t\trows: windows.map(window => this.generateNotes(it.id, window)),\n\t\t\t}\n\t\t})\n\t}\n\n\tgenerateNotes(actionId: number, window: HistoryEntry<EvaluatedAction[]>) {\n\t\tconst usedInTime = this.wasActionUsedInTime(actionId, this.gcdThreshold, window)\n\t\treturn <Icon\n\t\t\tname={usedInTime ? 'checkmark' : 'remove'}\n\t\t\tclassName={usedInTime ? 'text-success' : 'text-error'}\n\t\t/>\n\t}\n\n\tsuggest(windows: Array<HistoryEntry<EvaluatedAction[]>>) {\n\t\tconst wrongUsages = this.actions.map(action =>\n\t\t\t// For each action, counts the amount of times skill was not used in time in every window\n\t\t\twindows.map(window => Number(!this.wasActionUsedInTime(action.id, this.gcdThreshold, window)))\n\t\t\t\t.reduce((acc, it) => acc + it, 0)\n\t\t).reduce((acc, it) => acc + it, 0)\n\n\t\treturn new TieredSuggestion({\n\t\t\ticon: this.suggestionIcon,\n\t\t\tcontent: this.suggestionContent,\n\t\t\ttiers: this.severityTiers,\n\t\t\tvalue: wrongUsages,\n\t\t\twhy: <Trans id=\"brd.rs.suggestions.buff-evaluator.why\">\n\t\t\t\t<Plural value={wrongUsages} one=\"# cast of recommended actions was\" other=\"# casts of recommended actions were\"/> used later than optimal, or not at all.\n\t\t\t</Trans>,\n\t\t})\n\t}\n\n\t/**\n\t * Checks if given {actionId} was used before GCD #{gcdThreshold}\n\t * @param actionId\n\t * @param gcdThreshold\n\t * @param window\n\t */\n\tprivate wasActionUsedInTime = (actionId: number, gcdThreshold: number, window: HistoryEntry<EvaluatedAction[]>): boolean => {\n\t\tconst buffAction = _.first(window.data.filter(it => it.action.id === actionId))\n\n\t\t// Buff was not used, thus it was not in time\n\t\tif (buffAction === undefined) { return false }\n\n\t\tconst gcdThresholdAction = _.last(\n\t\t\twindow.data\n\t\t\t\t.filter(it => it.action.onGcd)\n\t\t\t\t.slice(0, gcdThreshold)\n\t\t)\n\n\t\t// There's no limiting GCD in the window, so can only assume it was used in time\n\t\tif (gcdThresholdAction === undefined) { return true }\n\n\t\t// Used in time if it was used before specified GCD\n\t\treturn buffAction.timestamp < gcdThresholdAction.timestamp\n\t}\n}\n\nexport class RagingStrikes extends BuffWindow {\n\tstatic override handle = 'rs'\n\tstatic override title = t('brd.rs.title')`Raging Strikes`\n\tstatic override displayOrder = DISPLAY_ORDER.RAGING_STRIKES\n\n\t@dependency private globalCooldown!: GlobalCooldown\n\t@dependency private actors!: Actors\n\n\toverride buffStatus = this.data.statuses.RAGING_STRIKES\n\n\tprivate museHistory: MuseWindow[] = []\n\tprivate barrageRemoves: number[] = []\n\n\toverride initialise() {\n\t\tsuper.initialise()\n\n\t\tthis.ignoreActions(SUPPORT_ACTIONS.map(actionKey => this.data.actions[actionKey].id))\n\n\t\tconst playerFilter = filter<Event>().source(this.parser.actor.id)\n\t\tconst buffFilter = playerFilter.status(this.data.statuses.ARMYS_MUSE.id)\n\t\tthis.addEventHook(buffFilter.type('statusApply'), this.onApplyMuse)\n\t\tthis.addEventHook(buffFilter.type('statusRemove'), this.onRemoveMuse)\n\t\tthis.addEventHook(playerFilter.status(this.data.statuses.BARRAGE.id).type('statusRemove'), this.onRemoveBarrage)\n\n\t\tconst suggestionWindowName = <DataLink action=\"RAGING_STRIKES\" showIcon={false} />\n\t\tthis.addEvaluator(new ExpectedGcdCountEvaluator({\n\t\t\texpectedGcds: 8,\n\t\t\tglobalCooldown: this.globalCooldown,\n\t\t\thasStacks: false,\n\t\t\tsuggestionIcon: this.data.actions.RAGING_STRIKES.icon,\n\t\t\tsuggestionContent: <Trans id=\"brd.rs.suggestions.missedgcd.content\">\n\t\t\t\tTry to land 8 GCDs (9 GCDs with <DataLink status=\"ARMYS_MUSE\"/>) during every <DataLink action=\"RAGING_STRIKES\"/> window.\n\t\t\t</Trans>,\n\t\t\tsuggestionWindowName,\n\t\t\tseverityTiers: {\n\t\t\t\t1: SEVERITY.MINOR,\n\t\t\t\t3: SEVERITY.MEDIUM,\n\t\t\t\t5: SEVERITY.MAJOR,\n\t\t\t},\n\t\t\tadjustCount: this.adjustExpectedGcdCount.bind(this),\n\t\t}))\n\n\t\tthis.addEvaluator(new BarrageEvaluator({\n\t\t\texpectedActions: [\n\t\t\t\t{\n\t\t\t\t\taction: this.data.actions.BARRAGE,\n\t\t\t\t\texpectedPerWindow: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\taction: this.data.actions.IRON_JAWS,\n\t\t\t\t\texpectedPerWindow: 1,\n\t\t\t\t},\n\t\t\t],\n\t\t\tsuggestionIcon: this.data.actions.BARRAGE.icon,\n\t\t\tsuggestionContent: <Trans id=\"brd.rs.suggestions.trackedactions.content\">\n\t\t\t\tOne use of <DataLink action=\"BARRAGE\"/> and one use of <DataLink action=\"IRON_JAWS\"/> should occur during every <DataLink action=\"RAGING_STRIKES\"/> window.\n\t\t\t</Trans>,\n\t\t\tsuggestionWindowName,\n\t\t\tseverityTiers: {\n\t\t\t\t1: SEVERITY.MINOR,\n\t\t\t\t3: SEVERITY.MEDIUM,\n\t\t\t\t5: SEVERITY.MAJOR,\n\t\t\t},\n\t\t\tadjustCount: this.adjustExpectedActionCount.bind(this),\n\t\t\tadjustOutcome: this.adjustExpectedActionOutcome.bind(this),\n\t\t\tbarrageId: this.data.actions.BARRAGE.id,\n\t\t\twasBarrageUsed: this.wasBarrageUsed.bind(this),\n\t\t}))\n\n\t\tthis.addEvaluator(new BuffEvaluator({\n\t\t\tactions: [this.data.actions.BATTLE_VOICE,\n\t\t\t\tthis.data.actions.RADIANT_FINALE,\n\t\t\t],\n\t\t\tgcdThreshold: BUFF_BEST_USED_BEFORE_GCD,\n\t\t\tsuggestionContent: <Trans id=\"brd.rs.suggestions.buff-evaluator.content\">\n\t\t\t\tUsing <DataLink action=\"RADIANT_FINALE\" /> and <DataLink action=\"BATTLE_VOICE\" /> within the first two GCDs of <DataLink action=\"RAGING_STRIKES\" /> windows allows you to better align their duration and maximize the multiplicative bonuses these statuses give you.\n\t\t\t</Trans>,\n\t\t\tsuggestionIcon: this.data.actions.RADIANT_FINALE.icon,\n\t\t\tseverityTiers: {\n\t\t\t\t1: SEVERITY.MINOR,\n\t\t\t\t2: SEVERITY.MEDIUM,\n\t\t\t\t3: SEVERITY.MAJOR,\n\t\t\t},\n\t\t}))\n\n\t\tthis.addEvaluator(new ExpectedActionsEvaluator({\n\t\t\texpectedActions: [\n\t\t\t\t{\n\t\t\t\t\taction: this.data.actions.APEX_ARROW,\n\t\t\t\t\texpectedPerWindow: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\taction: this.data.actions.BLAST_ARROW,\n\t\t\t\t\texpectedPerWindow: 1,\n\t\t\t\t},\n\t\t\t],\n\t\t\tsuggestionIcon: this.data.actions.BLAST_ARROW.icon,\n\t\t\tsuggestionContent: <Trans id=\"brd.rs.suggestions.aaba-evaluator.content\">\n\t\t\t\tOne use of <DataLink action=\"APEX_ARROW\"/> and <DataLink action=\"BLAST_ARROW\"/> should occur during every <DataLink action=\"RAGING_STRIKES\"/> window after the opener. Make sure you have at least 80 Soul Voice Gauge for your buffs.\n\t\t\t</Trans>,\n\t\t\tsuggestionWindowName,\n\t\t\tseverityTiers: {\n\t\t\t\t1: SEVERITY.MEDIUM,\n\t\t\t\t3: SEVERITY.MAJOR,\n\t\t\t},\n\t\t\tadjustCount: this.adjustExpectedApexCount.bind(this),\n\t\t}))\n\n\t\tthis.addEvaluator(new ExpectedActionGroupsEvaluator({\n\t\t\texpectedActionGroups: [{\n\t\t\t\tactions: [this.data.actions.BLOODLETTER, this.data.actions.RAIN_OF_DEATH],\n\t\t\t\texpectedPerWindow: 3,\n\t\t\t}],\n\t\t\tsuggestionIcon: this.data.actions.BLOODLETTER.icon,\n\t\t\tsuggestionContent: <Trans id=\"brd.rs.suggestions.bloodletter-evaluator.content\">\n\t\t\t\tAt least three uses of <DataLink action=\"BLOODLETTER\"/> or <DataLink action=\"RAIN_OF_DEATH\"/> should occur during every <DataLink action=\"RAGING_STRIKES\"/> window. Make sure you pool your <DataLink action=\"BLOODLETTER\"/> or <DataLink action=\"RAIN_OF_DEATH\"/> charges during <DataLink action=\"ARMYS_PAEON\"/>.\n\t\t\t</Trans>,\n\t\t\tsuggestionWindowName,\n\t\t\tseverityTiers: {\n\t\t\t\t1: SEVERITY.MINOR,\n\t\t\t\t3: SEVERITY.MEDIUM,\n\t\t\t\t5: SEVERITY.MAJOR,\n\t\t\t},\n\t\t}))\n\t}\n\n\tprivate get activeMuse(): MuseWindow | undefined {\n\t\tconst last = _.last(this.museHistory)\n\t\tif (last && !isDefined(last.end)) {\n\t\t\treturn last\n\t\t}\n\t\treturn undefined\n\t}\n\n\tprivate onApplyMuse(event: Events['statusApply']) {\n\t\tthis.museHistory.push({start: event.timestamp})\n\t}\n\n\tprivate onRemoveMuse(event: Events['statusRemove']) {\n\t\tif (this.activeMuse) {\n\t\t\tthis.activeMuse.end = event.timestamp\n\t\t}\n\t}\n\n\tprivate onRemoveBarrage(event: Events['statusRemove']) {\n\t\tthis.barrageRemoves.push(event.timestamp)\n\t}\n\n\tprivate adjustExpectedGcdCount(window: HistoryEntry<EvaluatedAction[]>) {\n\t\t// Check if muse was up for at least 3 GCDs in this buffWindow\n\t\tconst museOverlap = this.museHistory.some(muse => (\n\t\t\twindow.data.filter(event => this.data.getAction(event.action.id)?.onGcd &&\n\t\t\t\tevent.timestamp > muse.start && (!muse.end || event.timestamp < muse.end))\n\t\t\t\t.length >= MIN_MUSE_GCDS\n\t\t))\n\n\t\treturn museOverlap ? 1 : 0\n\t}\n\n\tprivate adjustExpectedActionCount(window: HistoryEntry<EvaluatedAction[]>, action: TrackedAction) {\n\t\t/**\n\t\t * IJ definitely shouldn't be used at the end of the fight, so reduce by 1\n\t\t * Barrage might have floated to the end of the RS window, so reduce by 1\n\t\t */\n\t\tif (this.isRushedEndOfPullWindow(window)) {\n\t\t\treturn -1\n\t\t}\n\n\t\t// If the action was Iron Jaws, the upper limit = the number of enemies we cast something on during this RS window\n\t\tif (action.action !== this.data.actions.IRON_JAWS) {\n\t\t\treturn 0\n\t\t}\n\n\t\tconst enemyIDs = new Set<string>()\n\t\twindow.data\n\t\t\t.filter(e => this.actors.get(e.target).team === Team.FOE)\n\t\t\t.forEach(e => enemyIDs.add(e.target))\n\n\t\t// Baseline number of allowed Iron Jaws is 1 and this function is an adjustment.\n\t\treturn Math.max(enemyIDs.size - 1, 0)\n\t}\n\n\tprivate adjustExpectedActionOutcome(window: HistoryEntry<EvaluatedAction[]>, action: TrackedAction) {\n\t\t/**\n\t\t * Positive only if we had exactly one Iron Jaws in this RS\n\t\t * If expected > 1, we're in AoE and there is no clear rotation target, so don't highlight this cell\n\t\t */\n\t\tif (action.action === this.data.actions.IRON_JAWS) {\n\t\t\treturn (actual: number, expected?: number) => {\n\t\t\t\tif (!isDefined(expected) || expected > 1) {\n\t\t\t\t\treturn RotationTargetOutcome.NEUTRAL\n\t\t\t\t}\n\n\t\t\t\tif (actual === expected) {\n\t\t\t\t\treturn RotationTargetOutcome.POSITIVE\n\t\t\t\t}\n\n\t\t\t\treturn RotationTargetOutcome.NEGATIVE\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate adjustExpectedApexCount(window: HistoryEntry<EvaluatedAction[]>) {\n\t\t// If the action is Apex Arrow or Blast Arrow, shouldn't count at the first window of the fight,\n\t\t// since there's no gauge to be spent\n\t\tif (window.start - APEX_OPENER_BUFFER <= this.parser.pull.timestamp) {\n\t\t\treturn -1\n\t\t}\n\n\t\treturn 0\n\t}\n\n\tprivate wasBarrageUsed(window: HistoryEntry<EvaluatedAction[]>) {\n\t\tconst gcdTimestamps = window.data\n\t\t\t.filter(event => event.action.onGcd)\n\t\t\t.map(event => event.timestamp)\n\t\tif (gcdTimestamps.length === 0) { return false }\n\n\t\t// Check to make sure at least one GCD happened before the status expired\n\t\tconst firstGcd = gcdTimestamps[0]\n\t\treturn this.barrageRemoves.some(timestamp => firstGcd <= timestamp && timestamp <= (window.end ?? window.start))\n\t}\n}\n","import {Trans} from '@lingui/react'\nimport {ActionLink, StatusLink} from 'components/ui/DbLink'\nimport {Procs} from 'parser/core/modules/Procs'\nimport React from 'react'\n\nexport class RefulgentProcs extends Procs {\n\toverride trackedProcs = [\n\t\t{\n\t\t\tprocStatus: this.data.statuses.STRAIGHT_SHOT_READY,\n\t\t\tconsumeActions: [this.data.actions.REFULGENT_ARROW],\n\t\t},\n\t]\n\n\toverride showDroppedProcSuggestion = true\n\toverride droppedProcIcon = this.data.actions.REFULGENT_ARROW.icon\n\toverride droppedProcContent = <Trans id=\"brd.procs.suggestions.missed.content\">\n\t\tTry to use <ActionLink {...this.data.actions.REFULGENT_ARROW} /> whenever you have <StatusLink {...this.data.statuses.STRAIGHT_SHOT_READY} />.\n\t</Trans>\n\n\toverride showOverwroteProcSuggestion = true\n\toverride overwroteProcIcon = this.data.actions.REFULGENT_ARROW.icon\n\toverride overwroteProcContent = <Trans id=\"brd.procs.suggestions.overwritten.content\">\n\t\tAvoid using actions that grant <StatusLink {...this.data.statuses.STRAIGHT_SHOT_READY} /> when you\n\t\tcould use <ActionLink {...this.data.actions.REFULGENT_ARROW} /> instead.\n\t</Trans>\n}\n","import {ActionTimeline} from './ActionTimeline'\nimport {AlwaysBeCasting} from './AlwaysBeCasting'\nimport {DoTs} from './DoTs'\nimport {DriftingEa} from './DriftingEa'\nimport {Mitigation} from './Mitigation'\nimport {MultiHitSkills} from './MultiHitSkills'\nimport {OGCDDowntime} from './OGCDDowntime'\nimport {RagingStrikes} from './RagingStrikes'\nimport {RefulgentProcs} from './RefulgentProcs'\n\nexport default [\n\tActionTimeline,\n\tAlwaysBeCasting,\n\tDoTs,\n\tDriftingEa,\n\tMultiHitSkills,\n\tMitigation,\n\tOGCDDowntime,\n\tRagingStrikes,\n\tRefulgentProcs,\n]\n"],"names":["ItemDepth","ActionTimeline","CastTime","Cooldowns","Data","Timeline","resolvedRows","groupRows","action","this","addRow","content","constructor","rows","config","resolvedConfig","resolveConfig","push","addEventHook","onComplete","maybeAction","fullAction","undefined","data","getAction","actions","uses","cooldowns","cooldownHistory","id","length","name","populatedGroups","row","lateResolveLabel","label","resolveRowLabel","populateRow","forEach","specifier","groups","group","add","allGroups","has","finalConfig","Array","isArray","ensureArray","existingRow","get","isDefined","firstContent","Trans","timeline","ContainerRow","order","collapse","set","addCooldownItems","addChargeItems","chargeHistory","history","entry","duration","getCooldownDuration","start","parser","pull","timestamp","end","addItem","SimpleItem","className","item","delta","ActionItem","depth","ACTION","ChargeGainItem","CHARGE_GAIN","endReason","CooldownEndReason","castTime","forAction","Math","max","Analyser","handle","debug","dependency","Content","styles","Icon","BaseItem","AlwaysBeCasting","Checklist","Downtime","GlobalCooldown","SpeedAdjustments","gcdUptimeSuggestionContent","gcdUptime","gcdsCounted","lastBeginCast","filter","source","actor","type","onBeginCast","onCast","event","onGcd","forEvent","globalCooldown","getDuration","ANIMATION_LOCK","recastTime","recastForEvent","castStart","considerCast","relativeTimestamp","formatEpochTimestamp","_action","downtime","isDowntime","fightDuration","currentDuration","getDowntime","uptime","checklist","Rule","description","displayOrder","requirements","Requirement","percent","getUptimePercent","target","speedAdjustments","DoTs","Actors","Invulnerability","Statuses","trackedStatuses","statusApplications","status","oneOf","onApply","getStatus","trackedStatus","trackedStatusOnTarget","lastApplied","totalClipping","excludeApplication","clip","addChecklistRules","addClippingSuggestions","statusId","statuses","getUptime","actors","foes","invulnerability","types","round","estimateHelp","__all","legacyFflogs","Statistics","getAdjustedDuration","BASE_GCD","isAdjustmentEstimated","estimated","isEstimated","statistics","SimpleStatistic","title","icon","ATTACK","value","formatDuration","info","report","meta","ft","statusSpecifier","targetSpecifier","targets","edges","edgesForActor","statusHistory","a","b","application","edge","side","events","apply","refresh","splitRangeForInvulns","statusDuration","remove","currentEpochTimestamp","min","range","finalRanges","invulns","getWindows","actorFilter","kind","invuln","previousRange","CoreActionTimeline","armyHistory","currentArmy","armyFilter","ARMYS_MUSE","ARMYS_PAEON","onApplyArmy","onRemoveArmy","armyDuration","acc","army","CoreAlwaysBeCasting","SEVERITIES","CLIPPING","SEVERITY","UPTIME","TARGET","Suggestions","CAUSTIC_BITE","STORMBITE","TieredRule","IRON_JAWS","tiers","meanClip","getClippingAmount","suggestions","TieredSuggestion","why","CoreDoTs","DriftingEa","driftedWindows","currentWindow","eaId","EMPYREAL_ARROW","castFilter","onDriftableCast","cooldown","window","observedUseTime","earliestUseTime","expectedUseTime","downtimeWindow","getDowntimeWindows","drift","driftedActionId","driftTable","Table","collapsing","unstackable","compact","Button","onClick","show","Fragment","Message","sheet","Mitigation","trackedDefensives","NATURES_MINNE","TROUBADOUR","Defensives","MultiHitSkills","suggestionIcon","ACTIONS","trackedActions","aoeAction","stActions","minTargets","AoEUsages","displayerOrder","OGCDDowntime","trackedCds","firstUseOffset","allowedAverageDowntime","BATTLE_VOICE","RADIANT_FINALE","RAGING_STRIKES","BARRAGE","SIDEWINDER","CooldownDowntime","SUPPORT_ACTIONS","BarrageEvaluator","opts","barrageId","wasBarrageUsed","ExpectedActionsEvaluator","BuffEvaluator","opt","gcdThreshold","suggestionContent","suggestionWhy","severityTiers","wasActionUsedInTime","actionId","buffAction","it","gcdThresholdAction","windows","format","header","showName","accessor","generateNotes","usedInTime","wrongUsages","Number","RagingStrikes","buffStatus","museHistory","barrageRemoves","ignoreActions","actionKey","playerFilter","buffFilter","onApplyMuse","onRemoveMuse","onRemoveBarrage","suggestionWindowName","showIcon","addEvaluator","ExpectedGcdCountEvaluator","expectedGcds","hasStacks","adjustCount","adjustExpectedGcdCount","bind","expectedActions","expectedPerWindow","adjustExpectedActionCount","adjustOutcome","adjustExpectedActionOutcome","APEX_ARROW","BLAST_ARROW","adjustExpectedApexCount","ExpectedActionGroupsEvaluator","expectedActionGroups","BLOODLETTER","RAIN_OF_DEATH","last","activeMuse","some","muse","isRushedEndOfPullWindow","enemyIDs","e","team","Team","size","actual","expected","RotationTargetOutcome","gcdTimestamps","firstGcd","BuffWindow","RefulgentProcs","trackedProcs","procStatus","STRAIGHT_SHOT_READY","consumeActions","REFULGENT_ARROW","showDroppedProcSuggestion","droppedProcIcon","droppedProcContent","showOverwroteProcSuggestion","overwroteProcIcon","overwroteProcContent","Procs"],"sourceRoot":""}